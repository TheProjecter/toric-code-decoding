#include "lattice.h"						#include "lattice.h"
#include "constants.h"						#include "constants.h"


// Constructor generates a unit cell. In case of the surface  |	// Constructor generates a unit cell. In case of the toric co
Cell::Cell (double & p)					      |	//Cell::Cell (double & p) {
							      >	Cell::Cell (void)
{								{
    ErrInit    = new Operator (1);				    ErrInit    = new Operator (1);
    ErrInit->generateRandom (p);			      |	    //ErrInit->generateRandom (p);
    // ErrCurrent is a copy of the random ErrInit		    // ErrCurrent is a copy of the random ErrInit
    ErrCurrent = new Operator (*ErrInit);		      |	    //ErrCurrent = new Operator (*ErrInit);
							      >	    ErrCurrent = new Operator(1);
    ErrGuess   = new Operator (1);				    ErrGuess   = new Operator (1);

}								}


// Destructor for a unit cell.					// Destructor for a unit cell.
Cell::~Cell (void)						Cell::~Cell (void)
{								{
    delete ErrInit;						    delete ErrInit;
    delete ErrCurrent;						    delete ErrCurrent;
    delete ErrGuess;						    delete ErrGuess;
}								}


// Constructor of a vertex representing an operator in the tr	// Constructor of a vertex representing an operator in the tr
Vertex::Vertex (int newX, int newY)			      |	Vertex::Vertex (int newX, int newY, int newT)
{								{
    x  = newX;							    x  = newX;
    y  = newY;							    y  = newY;
							      >	    t  = newT;
}								}


// Constructor generates the lattice.				// Constructor generates the lattice.
Lattice::Lattice(int newXSize, double p)		      |	Lattice::Lattice(int newXSize, int newT)
{								{

    xSize = 2*newXSize;						    xSize = 2*newXSize;
    ySize = 2*newXSize;						    ySize = 2*newXSize;
							      >	    T	= newT;
							      >

// zSize: 0 is the syndrome level, 1,2,3,4 are the qubit indi	// zSize: 0 is the syndrome level, 1,2,3,4 are the qubit indi
    zSize = 5;							    zSize = 5;

							      >
    cells = new Cell***[xSize];					    cells = new Cell***[xSize];
    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
        cells[i] = new Cell**[ySize];				        cells[i] = new Cell**[ySize];
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            cells[i][j] = new Cell *[zSize];			            cells[i][j] = new Cell *[zSize];
            for ( int k = 0; k < zSize; k++)			            for ( int k = 0; k < zSize; k++)
            {							            {
                //if k= 0     OR  i,j both odd OR    both eve	                //if k= 0     OR  i,j both odd OR    both eve
                if ( k == 0 || (i%2 && j%2)  || (!(i%2) && !(	                if ( k == 0 || (i%2 && j%2)  || (!(i%2) && !(
                {						                {
                    continue;					                    continue;
                }						                }

                //otherwise, if only one of i,j is odd  and k	                //otherwise, if only one of i,j is odd  and k
                if(debug6)					                if(debug6)
                {						                {
                    cout<< i<<j<<k<<" ";			                    cout<< i<<j<<k<<" ";
                }						                }
                cells[i][j][k] = new Cell (p);		      |	                cells[i][j][k] = new Cell ();

            }//end of k						            }//end of k
        }//end of j						        }//end of j
    }// end of i						    }// end of i


}								}


// Destructor of the lattice.					// Destructor of the lattice.
Lattice::~Lattice(void)						Lattice::~Lattice(void)
{								{

    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            for (int k = 0; k < zSize; k++)			            for (int k = 0; k < zSize; k++)
            {							            {
                if ((k ==0) || (i%2 && j%2) || (!(i%2) && !(j |	                if ((k == 0 )  || (i%2 && j%2) || (!(i%2) && 
                    continue;					                    continue;
                delete cells[i][j][k];				                delete cells[i][j][k];
            }							            }
            delete[] cells[i][j];				            delete[] cells[i][j];
        }							        }
        delete[] cells[i];					        delete[] cells[i];
    }								    }
    delete cells;						    delete cells;

}								}




// Calculates Octaeder plaquette syndrome at (around) the spe	// Calculates Octaeder plaquette syndrome at (around) the spe
bool Lattice::OCTsyndromeZZZZZZZZ (int xLoc, int yLoc)	      |	bool Lattice::OCTsyndromeZZZZZZZZ (int xLoc, int yLoc, double
{								{
//both i,j odd							//both i,j odd

    /* Debug						      <
    cout<<" xLoc "<< xLoc <<"  xSize "<< xSize <<" yLoc  " << <

    */							      |	//cout<<" xLoc "<< xLoc <<"  xSize "<< xSize <<" yLoc  " <<yL
							      >
							      >
    assert (xLoc < xSize && yLoc < ySize && (xLoc % 2) && (yL	    assert (xLoc < xSize && yLoc < ySize && (xLoc % 2) && (yL

							      >	    //q could be modeled here as well
							      >	    double q = q_err;
							      >
							      >
    bool result = false;					    bool result = false;

    Operator *P = new Operator(8);				    Operator *P = new Operator(8);
    P->ops[0]  = Z;						    P->ops[0]  = Z;
    P->ops[1]  = Z;						    P->ops[1]  = Z;
    P->ops[2]  = Z;						    P->ops[2]  = Z;
    P->ops[3]  = Z;						    P->ops[3]  = Z;
    P->ops[4]  = Z;						    P->ops[4]  = Z;
    P->ops[5]  = Z;						    P->ops[5]  = Z;
    P->ops[6]  = Z;						    P->ops[6]  = Z;
    P->ops[7]  = Z;						    P->ops[7]  = Z;

    Operator *plaquette = new Operator(8);			    Operator *plaquette = new Operator(8);

//Remember QB are					      |	//Remember QB indices are
//1--2								//1--2
//|  |								//|  |
//3--4								//3--4
    //One step left (if i is line, y is column) to the square |
							      >	    /*/DEBUG
							      >	    //test where the plaquette tests the cells
							      >	    cout << "xLoc  " << xLoc << "    yLoc-1  " << yLoc-1 << e
							      >	    cout << "xLoc+1modxSiyze  " << (xLoc+1)%xSize << "    yLo
							      >	    cout << "xLoc  " << xLoc << "    yLoc+1modySize  " << (yL
							      >	    cout << "xLoc-1  " << xLoc-1 <<"  yLoc  " << yLoc <<  end
							      >	    */
							      >
							      >
							      >
							      >	//One step left (if i is line, y is column) to the square, ge
    plaquette->ops[0]  = cells[xLoc][(yLoc-1+ySize)%ySize][2]	    plaquette->ops[0]  = cells[xLoc][(yLoc-1+ySize)%ySize][2]
    plaquette->ops[1]  = cells[xLoc][(yLoc-1+ySize)%ySize][4]	    plaquette->ops[1]  = cells[xLoc][(yLoc-1+ySize)%ySize][4]
    //One step down get QB 1,2					    //One step down get QB 1,2
    plaquette->ops[2]  = cells[(xLoc+1)%xSize][yLoc][1]->ErrC	    plaquette->ops[2]  = cells[(xLoc+1)%xSize][yLoc][1]->ErrC
    plaquette->ops[3]  = cells[(xLoc+1)%xSize][yLoc][2]->ErrC	    plaquette->ops[3]  = cells[(xLoc+1)%xSize][yLoc][2]->ErrC
// One step right, get QB 1,3					// One step right, get QB 1,3
    plaquette->ops[4]  = cells[xLoc][(yLoc+1)%ySize][1]->ErrC	    plaquette->ops[4]  = cells[xLoc][(yLoc+1)%ySize][1]->ErrC
    plaquette->ops[5]  = cells[xLoc][(yLoc+1)%ySize][3]->ErrC	    plaquette->ops[5]  = cells[xLoc][(yLoc+1)%ySize][3]->ErrC
//One step up get QB 3,4					//One step up get QB 3,4
    plaquette->ops[6]  = cells[(xLoc-1+xSize)%xSize][yLoc][3]	    plaquette->ops[6]  = cells[(xLoc-1+xSize)%xSize][yLoc][3]
    plaquette->ops[7]  = cells[(xLoc-1+xSize)%xSize][yLoc][4]	    plaquette->ops[7]  = cells[(xLoc-1+xSize)%xSize][yLoc][4]

    /* DEBUG						      <
    //test where the plaquette tests the cells		      <
    cout << "xLoc  " << xLoc << "    yLoc-1  " << yLoc-1 << e <
    cout << "xLoc+1modxSiyze  " << (xLoc+1)%xSize << "    yLo <
    cout << "xLoc  " << xLoc << "    yLoc+1modySize  " << (yL <
    cout << "xLoc-1  " << xLoc-1 <<"  yLoc  " << yLoc <<  end <

    */							      <

							      >		//Does it commute?
    result = !P->commute(*plaquette);				    result = !P->commute(*plaquette);

							      >	    //generate noisy syndrome measurement with propapility q
							      >	    double r = (double)rand() / ((double)RAND_MAX + 1);
							      >	    //if it shall have noise, then flip it
							      >	    if (r < q)
							      >	    {
							      >	        result = !result;
							      >	    }
							      >
							      >
    delete P;							    delete P;
    delete plaquette;						    delete plaquette;
    return result;						    return result;
}								}

// Calculates SQUARE plaquette syndrome at (around) the speci	// Calculates SQUARE plaquette syndrome at (around) the speci
bool Lattice::SQsyndromeZZZZ (int xLoc, int yLoc)	      |	bool Lattice::SQsyndromeZZZZ (int xLoc, int yLoc, double q_er
{								{
//exactly one of i,j odd and one even				//exactly one of i,j odd and one even
    assert (xLoc < xSize && yLoc < ySize && ( ((xLoc % 2) && 	    assert (xLoc < xSize && yLoc < ySize && ( ((xLoc % 2) && 

							      >
							      >	    //q could be modeled here as well
							      >	    double q = q_err;
    bool result = false;					    bool result = false;

    Operator *P = new Operator(4);				    Operator *P = new Operator(4);
    P->ops[0]  = Z;						    P->ops[0]  = Z;
    P->ops[1]  = Z;						    P->ops[1]  = Z;
    P->ops[2]  = Z;						    P->ops[2]  = Z;
    P->ops[3]  = Z;						    P->ops[3]  = Z;


    Operator *plaquette = new Operator(4);			    Operator *plaquette = new Operator(4);

//Remember QB are					      |	//Remember QB indices are
//1--2								//1--2
//|ij|								//|ij|
//3--4								//3--4
    plaquette->ops[0]  = cells[xLoc][yLoc][1]->ErrCurrent->op	    plaquette->ops[0]  = cells[xLoc][yLoc][1]->ErrCurrent->op
    plaquette->ops[1]  = cells[xLoc][yLoc][2]->ErrCurrent->op	    plaquette->ops[1]  = cells[xLoc][yLoc][2]->ErrCurrent->op
    plaquette->ops[2]  = cells[xLoc][yLoc][3]->ErrCurrent->op	    plaquette->ops[2]  = cells[xLoc][yLoc][3]->ErrCurrent->op
    plaquette->ops[3]  = cells[xLoc][yLoc][4]->ErrCurrent->op	    plaquette->ops[3]  = cells[xLoc][yLoc][4]->ErrCurrent->op



    result = !P->commute(*plaquette);				    result = !P->commute(*plaquette);

							      >
							      >
							      >
							      >	    //generate noisy syndrome measurement with propapility q
							      >	    double r = (double)rand() / ((double)RAND_MAX + 1);
							      >	    //if it shall have noise, then flip it
							      >	    if (r < q)
							      >	    {
							      >	        result = !result;
							      >	    }
							      >
							      >
    delete P;							    delete P;
    delete plaquette;						    delete plaquette;
    return result;						    return result;
}								}


// Calculates a signature which is a concatentation of all si	// Calculates a signature which is a concatentation of all si
vector<bool> Lattice::getSignature (void)			vector<bool> Lattice::getSignature (void)
{								{

    // The signature starts out empty				    // The signature starts out empty
    vector<bool> signature;					    vector<bool> signature;



    // Add ZZZZ syndromes					    // Add ZZZZ syndromes
    for (int i = 1; i < xSize; i+=2)				    for (int i = 1; i < xSize; i+=2)
    {								    {
        for (int j = 1; j < ySize; j+=2)			        for (int j = 1; j < ySize; j+=2)
        {							        {
            signature.push_back(SQsyndromeZZZZ(i,j));	      |	            // signature.push_back(SQsyndromeZZZZ(i,j));
        }							        }
    }								    }

    return signature;						    return signature;
}								}


//  Transform X or Z errors at the specified location.		//  Transform X or Z errors at the specified location.
void Lattice::correct ( int xLoc, int yLoc, int QubitNr)	void Lattice::correct ( int xLoc, int yLoc, int QubitNr)
{								{
    if (debug4)							    if (debug4)
    {								    {
        cout<< "xsize,ysixze,ysize "<<xSize<<ySize<<zSize<<en	        cout<< "xsize,ysixze,ysize "<<xSize<<ySize<<zSize<<en
        cout<< "xLoc,yLoc,QBNr "<<xLoc<<yLoc<<QubitNr<<endl;	        cout<< "xLoc,yLoc,QBNr "<<xLoc<<yLoc<<QubitNr<<endl;
    }								    }
    assert (xLoc < xSize && yLoc < ySize && QubitNr < zSize);	    assert (xLoc < xSize && yLoc < ySize && QubitNr < zSize);

//X*X=I								//X*X=I
    pauli p = X;						    pauli p = X;

    // Correct the error					    // Correct the error
    cells[xLoc][yLoc][QubitNr]->ErrCurrent->ops[0] = cells[xL	    cells[xLoc][yLoc][QubitNr]->ErrCurrent->ops[0] = cells[xL
    cells[xLoc][yLoc][QubitNr]->ErrGuess->ops[0] = cells[xLoc	    cells[xLoc][yLoc][QubitNr]->ErrGuess->ops[0] = cells[xLoc

    if (debug1)							    if (debug1)
    {								    {
        cout << " -> correcting " << p << " at x=" << xLoc <<	        cout << " -> correcting " << p << " at x=" << xLoc <<
    }								    }
    if (debug3)							    if (debug3)
    {								    {
        cout << " -> correcting " << p << " at x=" << xLoc <<	        cout << " -> correcting " << p << " at x=" << xLoc <<
    }								    }

}//end of correct()						}//end of correct()


							      >
							      >	//evolutes the lattice in time
							      >	void Lattice::evolute(double p_err)
							      >	{
							      >	    //qubit error
							      >	    double p = p_err;
							      >
							      >	    for (int i = 0; i < xSize; i++)
							      >	    {
							      >	        for (int j = 0; j < ySize; j++)
							      >	        {
							      >	            for (int k = 0; k < zSize; k++)
							      >	            {
							      >
							      >
							      >					//produces 2D cross section t
							      >					//very nice debugging feature
							      >	                if (DEBUG2D)
							      >	                {
							      >
							      >	                    //only second line nr 1 gets errors
							      >	                    if (i==1 && !(j%2))  //j=1,3,5is syndrome
							      >	                    {
							      >	                        cells[i][j][1]->ErrInit->generate_ran
							      >	                        //and copy into Current
							      >	                        cells[i][j][1]->ErrCurrent->ops[0] = 
							      >	                        cells[i][j][2]->ErrInit->generate_ran
							      >	                        //and copy into Current
							      >	                        cells[i][j][2]->ErrCurrent->ops[0] = 
							      >	                    }
							      >
							      >
							      >
							      >
							      >	                }
							      >	                else
							      >	                {
							      >	                    //if k= 0     OR  i,j both odd OR    both
							      >	                    if ( k == 0 || (i%2 && j%2)  || (!(i%2) &
							      >	                    {
							      >	                        continue;
							      >	                    }
							      >	                    //otherwise, throw error at qubit
							      >	                    cells[i][j][k]->ErrInit->generate_random_
							      >	                    //and copy into Current
							      >	                    cells[i][j][k]->ErrCurrent->ops[0] = cell
							      >
							      >
							      >	                }
							      >
							      >	                //if that doesnt work, we need a copy method 
							      >	            }//endk
							      >	        }//endj
							      >	    }//endi
							      >
							      >
							      >
							      >
							      >
							      >
							      >
							      >
							      >
							      >	}//end of evolute
							      >
							      >
							      >
							      >
							      >
							      >
							      >
							      >
							      >
							      >
// Calls the mathcing algorithm to find pairs of squares with	// Calls the mathcing algorithm to find pairs of squares with
// and calls the correction subroutine.				// and calls the correction subroutine.
void Lattice::correctMesh ()				      |	void Lattice::evolute_and_correct (double p_err, double q_err
{								{

							      >	    //proper algorithm for q
							      >	    double p = p_err;
							      >	    double q_SQR = q_err_SQR;
							      >	    double q_OCT = q_err_OCT;
							      >
							      >
							      >	    /*
							      >	     General Structure:
							      >	     
							      >	    find proper algorithm for q, (is maybe done in simulation
							      >
							      >	    create history
							      >
							      >	    loop:
							      >	    evolute,measure,save
							      >
							      >	    create vertices
							      >
							      >	    match vertices
							      >
							      >	    correct

    // Identify vertices that represent squares/octagons with |
    vector<Vertex*> vertices;				      |	    */
							      >
							      >	    //Create 3d	history AND 3d ID Tracker
							      >	    bool*** history;
							      >	    history = new bool** [xSize];
							      >
							      >	    int*** IDTracker;
							      >	    IDTracker = new int** [xSize];
							      >
							      >	    int ID = 0;
							      >	    //fill history with false;
							      >	    //fill IDTracker with IDs
							      >	    if(debug10)
							      >	    {
							      >	        cout<<"Create history and ID Tracker:"<<endl;
							      >	    }

    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
							      >	        history[i] = new bool *[ySize];
							      >	        IDTracker[i] = new int *[ySize];
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            bool syndrome = false;			      |	            history[i][j] = new bool [T+1];
// if i,j both odd do OCT-Z-syndrome (detects X Errors)	      |	            IDTracker[i][j] = new int [T+1];
							      |	            for (int t = 0; t < T+1; t++)
            if ( ((i%2) && (j%2)) )			      <
            {							            {
                syndrome = OCTsyndromeZZZZZZZZ(i,j);	      |	                if(debug10)
							      >	                {
							      >	                    cout<<i<<j<<t<<" ID: "<<ID<<endl;
							      >	                }
							      >	                history[i][j][t] = false;
							      >	                IDTracker[i][j][t] = ID;
							      >	                ID++;
							      >
            }							            }
//if exactly  one of i and j is odd and one is even do SQ-Z-S |	        }
							      >	    }

            if (  (i%2 && !(j%2))   ||   (!(i%2) && j%2) )    |
							      >	    //now evolute the lattice, measure after each time step a
							      >
							      >	    if (DEBUG2D)
							      >	    {
							      >	        cout<<"Evolution"<<endl;
							      >	    }
							      >
							      >
							      >	    //last T slice must be error free!
							      >	    for (int t = 0; t < T; t++)
							      >	    {
							      >
							      >	        //evolute
							      >	        this->evolute(p);
							      >
							      >
							      >	        if (DEBUG2D)
							      >	        {
							      >	            cout<<"T="<<t<<": ";
							      >	            print2DState();
							      >	        }
							      >
							      >	        //measure and save
							      >
							      >	        for (int i = 0; i < xSize; i++)
							      >	        {
							      >	            for (int j = 0; j < ySize; j++)
            {							            {
                syndrome = SQsyndromeZZZZ(i,j);		      <
            }						      <

            if (syndrome)				      |	                // if i,j both odd =square do sqr Zsyndrome, 
							      >	                // OR
							      >	                // if on Zoctagon (NOT Xoctagon) do oct Zsynd
							      >	                if ( (which_cell_type (i,j) == sqr && SQsyndr
							      >	                {
							      >	                    //save in history
							      >	                    history[i][j][t] = true;
							      >	                    if (debug3)
							      >	                    {
							      >	                        cout<<"history i,j,t = "<<i<<" "<<j<<
							      >	                    }
							      >	                }
							      >
							      >
							      >	            }//end of j
							      >	        }//end of i
							      >
							      >	    }//end of for t evolute and measure
							      >
							      >
							      >	//Maybe here, debug print history
							      >
							      >	    //Print history
							      >	    if (DEBUG2D)
							      >	    {
							      >	        cout<<"History"<<endl;
							      >	        for (int t = 0; t < T+1; t++)
							      >	        {
							      >
							      >	            cout<<"T="<<t<<": ";
							      >	            for (int i = 0; i < xSize; i++)
            {							            {
                if (debug1) cout << "Syndrome:"  << " i=" <<  |	                for (int j = 0; j < ySize; j++)
                Vertex* v = new Vertex (i, j);		      |	                {
                vertices.push_back(v);			      |
            }						      |
							      >	                    if (i==1)  //j=1,3,5is syndrome,0,2,4 is 
							      >	                    {
							      >	                        cout<< " "<<history[i][j][t]<<" ";
							      >
							      >
							      >	                    }
							      >
							      >	                }
							      >	                if (i==1)
							      >	                {
							      >	                    cout<<endl;
							      >	                }
							      >	            }//end of i
							      >
							      >	        }//endof t
							      >	    }
							      >
							      >
							      >
							      >
							      >
							      >
							      >	    if (DEBUG2D)
							      >	    {
							      >	        cout<<"Vertices"<<endl;
							      >	    }
							      >
							      >	    // Identify vertices that represent squares with change i
							      >	    vector<Vertex*> vertices;
							      >	    for (int t = 0; t < (T+1); t++)
							      >	    {
							      >	        if (DEBUG2D)
							      >	        {
							      >	            cout<<"T="<<t<<": ";
							      >	        }
							      >
							      >	        for (int i = 0; i < xSize; i++)
							      >	        {
							      >	            for (int j = 0; j < ySize; j++)
							      >	            {
							      >
							      >	                bool is_vertex = false;
							      >	                //is on Syndrome ij?
							      >	                // if i,j both odd(Zocto) OR exactly one odd 
							      >	                if ( (i%2 && j%2 ) ||  which_cell_type (i,j) 
							      >	                {
							      >	                    /*
							      >	                    in the first slice, every syndrome is a v
							      >	                    otherwise, check the current t and the on
							      >	                    if the syndrome changed, if->then it is c
							      >	                    */
							      >	                    if((t==0 && history[i][j][t]) || (t!=0 &&
							      >	                    {
							      >	                        is_vertex = true;
							      >	                    }//end if is vertex
							      >
							      >	                }//end of if Syndrome ij
							      >
							      >	                //Print vertex history
							      >	                if (DEBUG2D)
							      >	                {
							      >	                    if (i==1)
							      >	                    {
							      >	                        if(is_vertex)
							      >	                        {
							      >	                            cout<<" "<<vertices.size();
							      >	                            //if(vertices.size()<10){cout<<" 
							      >	                            cout<<" ";
							      >	                        }
							      >	                        else
							      >	                        {
							      >	                            cout<<" . ";
							      >	                        }
							      >
							      >	                    }
							      >	                }
							      >
							      >
							      >
							      >	                //if it is a vertex, save it
							      >	                if (is_vertex)
							      >	                {
							      >	                    if (debug1) cout << "Is_Vertex at: "  << 
							      >	                    Vertex* v = new Vertex (i, j, t);
							      >	                    vertices.push_back(v);
							      >	                }//end if is vertex
							      >
							      >
							      >	            } //end of loop j
							      >	        }//end of loop i
							      >
							      >	        if (DEBUG2D)
							      >	        {
							      >	            cout<<endl;
							      >	        }
							      >
							      >	    }//end of loop t
							      >
							      >
							      >
							      >	//now prepare for the minimum weight matching
							      >
							      >	    int numVert = vertices.size();
							      >	    int edges = 0;
							      >
							      >	    float** edgeLengths;
							      >	    edgeLengths = new float*[numVert];
							      >	    for (int i = 0; i < numVert; i++)
							      >	    {
							      >	        edgeLengths[i] = new float[numVert];
							      >	        for (int j = 0; j < numVert; j++)
							      >	        {
							      >	            edgeLengths[i][j] = -1.0;
        }							        }
    }								    }

    // Call minimum weight perfect matching		      |
							      >
							      >	    // Add all weighted edges (u,v) with weight w in complete
							      >	    for (int i = 0; i < numVert; i++)
							      >	    {
							      >	        //for every start vertex i get the ID
							      >	        int startID = IDTracker[vertices[i]->x][vertices[i]->
							      >	        for (int j = 0; j < numVert; j++)
							      >	        {
							      >	            if (i == j)
							      >	            {
							      >	                continue;
							      >	            }
							      >
							      >	            //for every end vertex j get the ID
							      >	            int endID = IDTracker[vertices[j]->x][vertices[j]
							      >	            //And get the minimum distance
							      >	            float dist = 0.000f;
							      >	            if(startID>endID)
							      >	            {
							      >	                dist = Dist[startID][endID];
							      >	            }
							      >	            else
							      >	            {
							      >	                dist = Dist[endID][startID];
							      >
							      >	            }
							      >
							      >
							      >	            //then save it
							      >	            edgeLengths[i][j] = dist;
							      >	            edges++;
							      >
							      >
							      >
							      >	        }//end of j
							      >	    }//end of i
							      >
							      >
							      >
							      >
							      >	// Call minimum weight perfect matching
    struct PerfectMatching::Options options;			    struct PerfectMatching::Options options;
    struct GeomPerfectMatching::GPMOptions gpm_options;		    struct GeomPerfectMatching::GPMOptions gpm_options;
    options.verbose = false;					    options.verbose = false;
							      >	    PerfectMatching *pm = new PerfectMatching(numVert,edges);
							      >
							      >	    for (int i = 0; i < numVert; i++)
							      >	    {
							      >	        for (int j = 0; j < numVert; j++)
							      >	        {
							      >	            double dist = edgeLengths[i][j];
							      >	            if (dist >= 0)
							      >	                pm->AddEdge(i,j,dist);
							      >	        }
							      >	    }
							      >
							      >
							      >
							      >	    pm->options = options;
							      >	    pm->Solve();
							      >
							      >
							      >
							      >	    if (debug4 || DEBUG2D)
							      >	    {
							      >	        for (int i = 0; i < numVert; i++ )
							      >	        {
							      >	            int j = pm->GetMatch(i);
							      >	            if (i<j)
							      >	            {
							      >	                cout<<"Matched: "<<i<<" and "<<j<<endl;
							      >	            }
							      >	        }
							      >	    }
							      >
							      >	    // Call the correction subroutine for all matched vertice
							      >	    for (int i = 0; i < numVert; i++ )
							      >	    {
							      >	        // i and j are matched
							      >	        int j = pm->GetMatch(i);
							      >	        //only correct:
							      >	        //-once
							      >	        // -those vertices whose connections has space compon
							      >	        //-the last history slice is special:
							      >	        //a path is in space and time, then it is corrected B
							      >	        // the last slice is without
							      >	        //error by default SO: only correct which matching pa
							      >
							      >
							      >	        if ( !(vertices[i]->t == T && vertices[j]->t == T) &&
							      >	        {
							      >	            if (debug4 ||DEBUG2D)
							      >	            {
							      >	                cout<<"Corrected: "<<i<<" to "<<j<<endl;
							      >	            }
							      >	            correctLine (vertices[i]->x, vertices[i]->y, vert
							      >
							      >
							      >	        }//end of if correct
							      >	    }//end of numVertices
							      >
							      >	    for (int i = 0; i < numVert; i++)
							      >	    {
							      >	        delete vertices[i];
							      >	    }
							      >
							      >	    delete pm;
							      >
							      >	    for (int i = 0; i < numVert; i++)
							      >	    {
							      >	        delete edgeLengths[i];
							      >	    }
							      >	    delete edgeLengths;
							      >
							      >
							      >	// Delete syndrome history AND IDTracker
							      >	    for (int i = 0; i < xSize; i++)
							      >	    {
							      >	        for (int j = 0; j < ySize; j++)
							      >	        {
							      >	            delete history[i][j];
							      >	            delete IDTracker[i][j];
							      >	        }
							      >	        delete history[i];
							      >	        delete IDTracker[i];
							      >	    }
							      >	    delete history;
							      >	    delete IDTracker;
							      >
							      >
							      >	}// end of evolute and correct
							      >
							      >
							      >
							      >
							      >
							      >	// Does one round of perfect syndrome measurement and correct
							      >	// Without it, it might not be part of the stabilizer
							      >	//(errors could still be in it)
							      >	void Lattice::perfect_correction(void)
							      >	{
							      >
							      >	    if (debug3)
							      >	    {
							      >	        cout<<"Evolute and Correct "<<endl;
							      >	    }
							      >
							      >	    double q_SQR = 0;
							      >	    double q_OCT = 0;
							      >
							      >
							      >
							      >	    //Create 1d
							      >	    bool*** history;
							      >
							      >
							      >	    history = new bool** [xSize];
							      >
							      >	    //fill history with false;
							      >	    for (int i = 0; i < xSize; i++)
							      >	    {
							      >	        history[i] = new bool *[ySize];
							      >	        for (int j = 0; j < ySize; j++)
							      >	        {
							      >	            history[i][j] = new bool [T+1];
							      >	            for (int t = 0; t < 1; t++)
							      >	            {
							      >	                history[i][j][t] = false;
							      >	            }
							      >	        }
							      >	    }
							      >
							      >
							      >	    //measure and save
							      >	    for (int t = 0; t < 1; t++)
							      >	    {
							      >	        for (int i = 0; i < xSize; i++)
							      >	        {
							      >	            for (int j = 0; j < ySize; j++)
							      >	            {
							      >
							      >	                // if i,j both odd =square do sqr Zsyndrome, 
							      >	                // OR
							      >	                // if on Zoctagon (NOT Xoctagon) do oct Zsynd
							      >	                if ( (which_cell_type (i,j) == sqr && SQsyndr
							      >	                {
							      >	                    //save in history
							      >	                    history[i][j][t] = true;
							      >	                    if (debug3)
							      >	                    {
							      >	                        cout<<"history i,j,t = "<<i<<" "<<j<<
							      >	                    }
							      >	                }
							      >
							      >
							      >	            }//end of j
							      >	        }//end of i
							      >	    }//end of t
							      >
							      >
							      >
							      >
							      >	    // Identify vertices that represent squares with change i
							      >	    vector<Vertex*> vertices;
							      >	    if (debug4)
							      >	    {
							      >	        cout<<"Vertices"<<endl;
							      >	    }
							      >
							      >	    for (int t = 0; t < 1; t++)
							      >	    {
							      >	        for (int i = 0; i < xSize; i++)
							      >	        {
							      >	            for (int j = 0; j < ySize; j++)
							      >	            {
							      >
							      >	                bool is_vertex = false;
							      >	                // if i,j both odd check if vertex
							      >	                if (( (i%2 && j%2 ) || ( (!(i%2) && j%2)  || 
							      >	                {
							      >	                    is_vertex = true;
							      >
							      >	                }//end of is vertex
							      >
							      >
							      >
							      >
							      >
							      >
							      >	                //if it is a vertex, save it
							      >	                if (is_vertex)
							      >	                {
							      >	                    if (debug3) cout << "Is_Vertex at: "  << 
							      >	                    Vertex* v = new Vertex (i, j, t);
							      >	                    vertices.push_back(v);
							      >
							      >	                }
							      >
							      >	            }//end of j
							      >
							      >	        }//end of i
							      >	    }//end of t
							      >
							      >
							      >
							      >
							      >
							      >

    int numVert = vertices.size();				    int numVert = vertices.size();
    int edges = (numVert*(numVert-1));			      |	    int edges = 0;
    PerfectMatching *pm = new PerfectMatching(numVert,edges); |
							      >	    double** edgeLengths;
							      >	    edgeLengths = new double*[numVert];
							      >	    for (int i = 0; i < numVert; i++)
							      >	    {
							      >	        edgeLengths[i] = new double[numVert];
							      >	        for (int j = 0; j < numVert; j++)
							      >	        {
							      >	            edgeLengths[i][j] = -1.0;
							      >	        }
							      >	    }
							      >
							      >

    // Add all weighted edges (u,v) with weight w in complete	    // Add all weighted edges (u,v) with weight w in complete
    for (int i = 0; i < numVert; i++)				    for (int i = 0; i < numVert; i++)
    {								    {
        for (int j = 0; j < numVert; j++)			        for (int j = 0; j < numVert; j++)
        {							        {
            if (i == j)						            if (i == j)
							      >	            {
                continue;					                continue;
            int deltaX = min (abs (vertices[i]->x - vertices[ |	            }
							      >
							      >
							      >
							      >				//this is the distance in x y t
							      >	            double deltaX = min (abs (vertices[i]->x - vertic
            //if both syndromes are both on the same odd colu	            //if both syndromes are both on the same odd colu
            //just a fancy specialty of this metrik (taxi-cab	            //just a fancy specialty of this metrik (taxi-cab
            if ( (vertices[i]->y == vertices[j]->y) && (!(ver	            if ( (vertices[i]->y == vertices[j]->y) && (!(ver
            {							            {
                deltaX = deltaX + 2;				                deltaX = deltaX + 2;
            }							            }

            int deltaY = min (abs (vertices[i]->y - vertices[ |	            double deltaY = min (abs (vertices[i]->y - vertic
            //if the syndromes are both on the same odd line 	            //if the syndromes are both on the same odd line 
            //just a fancy specialty of this metrik (taxi-cab	            //just a fancy specialty of this metrik (taxi-cab
            if ( (vertices[i]->x == vertices[j]->x) && (!(ver	            if ( (vertices[i]->x == vertices[j]->x) && (!(ver
            {							            {
                deltaY = deltaY + 2;				                deltaY = deltaY + 2;
            }							            }
            int dist   = (deltaX + deltaY);		      |
            pm->AddEdge(i,j,dist);			      |	            double deltaT = abs (vertices[i]->t - vertices[j]
							      >
							      >	            double dist   = deltaX + deltaY + deltaT;
							      >	            edgeLengths[i][j] = dist;
							      >	            edges++;
            if (debug1) cout << "Matching: i=" << i << " j= "	            if (debug1) cout << "Matching: i=" << i << " j= "
							      >	        }
							      >	    }
							      >
							      >
							      >
							      >	// Call minimum weight perfect matching
							      >	    struct PerfectMatching::Options options;
							      >	    struct GeomPerfectMatching::GPMOptions gpm_options;
							      >	    options.verbose = false;
							      >	    PerfectMatching *pm = new PerfectMatching(numVert,edges);

							      >	//cout<<"numVert: "<<numVert<<endl;
							      >
							      >	    for (int i = 0; i < numVert; i++)
							      >	    {
							      >	        for (int j = 0; j < numVert; j++)
							      >	        {
							      >	            double dist = edgeLengths[i][j];
							      >	            if (dist >= 0)
							      >	                pm->AddEdge(i,j,dist);
        }							        }
    }								    }

							      >
							      >
    pm->options = options;					    pm->options = options;
    pm->Solve();						    pm->Solve();

							      >	    if (debug4)
							      >	    {
							      >	        for (int i = 0; i < numVert; i++ )
							      >	        {
							      >	            int j = pm->GetMatch(i);
							      >	            if (i<j)
							      >	            {
							      >	                cout<<"Matched: "<<i<<" and "<<j<<endl;
							      >	            }
							      >	        }
							      >	    }
							      >
    // Call the correction subroutine for all matched vertice	    // Call the correction subroutine for all matched vertice
    for (int i = 0; i < numVert; i++ )				    for (int i = 0; i < numVert; i++ )
    {								    {
        // i and j are matched					        // i and j are matched
        int j = pm->GetMatch(i);				        int j = pm->GetMatch(i);
        if (i < j)					      |
            //cout<<"correctline" <<vertices[i]->x<<" "<< ver |	        if (  (i < j) && (j < numVert) && ( (vertices[i]->x !
							      >	        {
							      >	            if (debug4)
							      >	            {
							      >	                cout<<"Corrected: "<<i<<" to "<<j<<endl;
							      >	            }
            correctLine (vertices[i]->x, vertices[i]->y, vert	            correctLine (vertices[i]->x, vertices[i]->y, vert
							      >
							      >	        }
    }								    }

    for (int i = 0; i < numVert; i++)				    for (int i = 0; i < numVert; i++)
    {								    {
        delete vertices[i];					        delete vertices[i];
    }								    }
							      >
    delete pm;							    delete pm;

							      >	    for (int i = 0; i < numVert; i++)
							      >	    {
							      >	        delete edgeLengths[i];
							      >	    }
							      >	    delete edgeLengths;
							      >
							      >
							      >	// Delete syndrome history
							      >	    for (int i = 0; i < xSize; i++)
							      >	    {
							      >	        for (int j = 0; j < ySize; j++)
							      >	        {
							      >	            delete history[i][j];
							      >	        }
							      >	        delete history[i];
							      >	    }
							      >	    delete history;
							      >
							      >	    if (debug3)
							      >	    {
							      >	        cout<<"Finished Correction "<<endl;
							      >	    }
}								}


							      >
							      >
							      >
							      >
							      >
							      >
// Given the locations of two syndromes with a non-trivial sy	// Given the locations of two syndromes with a non-trivial sy
// connecting the two syndromes.				// connecting the two syndromes.
void Lattice::correctLine ( int x1Loc, int y1Loc, int x2Loc, 	void Lattice::correctLine ( int x1Loc, int y1Loc, int x2Loc, 
{								{

    // Initialize x1, y1, x2, y2 so that we can correct error	    // Initialize x1, y1, x2, y2 so that we can correct error
    // the SE or SW direction coming from coordinates 1 to co	    // the SE or SW direction coming from coordinates 1 to co

//x y-->							//x y-->
//I								//I
//v    EAST							//v    EAST
//  00 01 02							//  00 01 02
//N 10 11 13 South						//N 10 11 13 South
//  20 21 22							//  20 21 22
//  West							//  West

    int x1, y1, x2, y2;						    int x1, y1, x2, y2;
    if ( (y1Loc < y2Loc && y2Loc - y1Loc < ySize - y2Loc + y1	    if ( (y1Loc < y2Loc && y2Loc - y1Loc < ySize - y2Loc + y1
            (y2Loc < y1Loc && y1Loc - y2Loc > ySize - y1Loc +	            (y2Loc < y1Loc && y1Loc - y2Loc > ySize - y1Loc +
    {								    {
        x1 = x1Loc;						        x1 = x1Loc;
        y1 = y1Loc;						        y1 = y1Loc;
        x2 = x2Loc;						        x2 = x2Loc;
        y2 = y2Loc;						        y2 = y2Loc;
    }								    }
    else							    else
    {								    {
        x1 = x2Loc;						        x1 = x2Loc;
        y1 = y2Loc;						        y1 = y2Loc;
        x2 = x1Loc;						        x2 = x1Loc;
        y2 = y1Loc;						        y2 = y1Loc;
    }								    }

							      >
							      >	//A LONG WALK TO FREEDOM ALGORITHM
							      >
// go from x1|y1 -> x2|y2					// go from x1|y1 -> x2|y2
// y2 = y1+(...)%ySize						// y2 = y1+(...)%ySize

//DIRECTION							//DIRECTION
    // Determine if we need to go up, down or neither		    // Determine if we need to go up, down or neither
    vertical_direction v_dir = v_where_to_go(x1, x2);		    vertical_direction v_dir = v_where_to_go(x1, x2);
//up,down, neither, wrong_direction				//up,down, neither, wrong_direction

//HORIZONTAL Y-ACHSIS j						//HORIZONTAL Y-ACHSIS j
    // Determine if we need to start from sqr or oct		    // Determine if we need to start from sqr or oct
    celltype h_start_type = which_cell_type ( x1, y1);		    celltype h_start_type = which_cell_type ( x1, y1);
//sqr,oct,wrong_type						//sqr,oct,wrong_type
    // Determine if we need to start from sqr or oct		    // Determine if we need to start from sqr or oct
    celltype h_end_type = which_cell_type ( x1, y2);		    celltype h_end_type = which_cell_type ( x1, y2);

//VERTICAL X-ACHSIS i						//VERTICAL X-ACHSIS i
// Determine if we need to start from sqr or oct		// Determine if we need to start from sqr or oct
    celltype v_start_type = h_end_type;				    celltype v_start_type = h_end_type;
    // Determine if we need to start from sqr or oct		    // Determine if we need to start from sqr or oct
    celltype v_end_type = which_cell_type ( x2, y2);		    celltype v_end_type = which_cell_type ( x2, y2);

//Determine distance between syndromes				//Determine distance between syndromes

    int delta_x = delta_xy(x2,x1,xSize);			    int delta_x = delta_xy(x2,x1,xSize);
    int delta_y = delta_xy(y2,y1,ySize);			    int delta_y = delta_xy(y2,y1,ySize);








    /*old debugging						    /*old debugging
      if (debug1) cout << "Correcting line x1=" << x1 << " y1	      if (debug1) cout << "Correcting line x1=" << x1 << " y1
    */								    */

    if (debug3)							    if (debug3)
    {								    {
        cout <<endl<< "Correcting line x1=" << x1 << " y1=" <	        cout <<endl<< "Correcting line x1=" << x1 << " y1=" <
             << " direction= ";					             << " direction= ";
        if (v_dir==up)						        if (v_dir==up)
        {							        {
            cout<< " up "<<endl;				            cout<< " up "<<endl;
        }							        }
        else if (v_dir==down)					        else if (v_dir==down)
        {							        {
            cout<< " down "<<endl;				            cout<< " down "<<endl;
        }							        }
        else if (v_dir==neither)				        else if (v_dir==neither)
        {							        {
            cout<< " neither "<<endl;				            cout<< " neither "<<endl;
        }							        }
        cout<< "Start Horizontal= ";				        cout<< "Start Horizontal= ";
        if (h_start_type==sqr)					        if (h_start_type==sqr)
        {							        {
            cout<< " square "<<endl;				            cout<< " square "<<endl;
        }							        }
        else if (h_start_type==octo)				        else if (h_start_type==octo)
        {							        {
            cout<< " 0ctogon "<<endl;				            cout<< " 0ctogon "<<endl;
        }							        }
        cout<< "End Horizontal= ";				        cout<< "End Horizontal= ";
        if (h_end_type==sqr)					        if (h_end_type==sqr)
        {							        {
            cout<< " square "<<endl;				            cout<< " square "<<endl;
        }							        }
        else if (h_end_type==octo)				        else if (h_end_type==octo)
        {							        {
            cout<< " 0ctogon "<<endl;				            cout<< " 0ctogon "<<endl;
        }							        }
        cout<< "Start Vertical= ";				        cout<< "Start Vertical= ";
        if (v_start_type==sqr)					        if (v_start_type==sqr)
        {							        {
            cout<< " square "<<endl;				            cout<< " square "<<endl;
        }							        }
        else if (v_start_type==octo)				        else if (v_start_type==octo)
        {							        {
            cout<< " 0ctogon "<<endl;				            cout<< " 0ctogon "<<endl;
        }							        }
        cout<< "End Vertical= ";				        cout<< "End Vertical= ";
        if (v_end_type==sqr)					        if (v_end_type==sqr)
        {							        {
            cout<< " square "<<endl;				            cout<< " square "<<endl;
        }							        }
        else if (v_end_type==octo)				        else if (v_end_type==octo)
        {							        {
            cout<< " 0ctogon "<<endl;				            cout<< " 0ctogon "<<endl;
        }							        }
        cout<< "Delta_y= "<<delta_xy(y2,y1,ySize)<<endl;	        cout<< "Delta_y= "<<delta_xy(y2,y1,ySize)<<endl;
        cout<< "Delta_x= "<<delta_xy(x2,x1,xSize)<<endl;	        cout<< "Delta_x= "<<delta_xy(x2,x1,xSize)<<endl;
    }								    }
/////////////////////////////////////////////HORIZONTAL		/////////////////////////////////////////////HORIZONTAL
    // correct in the horizontal direction first		    // correct in the horizontal direction first
//Qubits to correct in horizontal y Achsis			//Qubits to correct in horizontal y Achsis
//y1 ++ to y2							//y1 ++ to y2


// use correct( x1, y1, qubitcorr)				// use correct( x1, y1, qubitcorr)

    //do we need to correct in horizontal direction?		    //do we need to correct in horizontal direction?
    if (delta_y != 0)						    if (delta_y != 0)
    {								    {

        if (debug4)						        if (debug4)
        {							        {
            cout<<"delta_y != 0"<<endl;				            cout<<"delta_y != 0"<<endl;
        }							        }
        //then start correction					        //then start correction

        //exitvariable						        //exitvariable
        bool exit = false;					        bool exit = false;
        //exit next time variable				        //exit next time variable
        bool exitnextloop = false;				        bool exitnextloop = false;


        //laufvariable						        //laufvariable
        int Y = y1;						        int Y = y1;
        //countingvariable counting the amount of corrections	        //countingvariable counting the amount of corrections
        int l = 1;						        int l = 1;

        //while exit is false					        //while exit is false
        while (!exit)						        while (!exit)
        {							        {

            if (debug4)						            if (debug4)
            {							            {
                cout<<"Y, y2: "<<Y<<" "<<y2<<endl;		                cout<<"Y, y2: "<<Y<<" "<<y2<<endl;
            }							            }


            //only if on an octagon				            //only if on an octagon
            if ( which_cell_type(x1,Y) == octo)			            if ( which_cell_type(x1,Y) == octo)
            {							            {

                if (debug4)					                if (debug4)
                {						                {
                    cout<<" is octagon "<<endl;			                    cout<<" is octagon "<<endl;
                }						                }

                //initialize the stuff!				                //initialize the stuff!
                bool first = false;				                bool first = false;
                bool last = false;				                bool last = false;
                correctiontype whatcorrection = wrong_correct	                correctiontype whatcorrection = wrong_correct
                correctiontypeQB whatcorrectionqubit = wrong_	                correctiontypeQB whatcorrectionqubit = wrong_


                //check if first				                //check if first
                if ( l == 1)					                if ( l == 1)
                {						                {
                    first = true;				                    first = true;
                }						                }

                //check if last					                //check if last
                if ( delta_xy(Y,y2,ySize) <= 1 )		                if ( delta_xy(Y,y2,ySize) <= 1 )
                {						                {
                    last = true;				                    last = true;
                }						                }

                //Determine correctiontype			                //Determine correctiontype
                if ( last && h_end_type == octo )		                if ( last && h_end_type == octo )
                {						                {
                    whatcorrection = before;			                    whatcorrection = before;
                }						                }
                else if (first && h_start_type)			                else if (first && h_start_type)
                {						                {
                    whatcorrection = next;			                    whatcorrection = next;
                }						                }
                else						                else
                {						                {
                    whatcorrection = four;			                    whatcorrection = four;
                }						                }

                //Determine correctiontypequbit			                //Determine correctiontypequbit

                if ( (whatcorrection == before) && ( v_dir ==	                if ( (whatcorrection == before) && ( v_dir ==
                {						                {
                    whatcorrectionqubit = before_up;		                    whatcorrectionqubit = before_up;
                }						                }
                else if ( (whatcorrection == before) && ( v_d	                else if ( (whatcorrection == before) && ( v_d
                {						                {
                    whatcorrectionqubit = before_down;		                    whatcorrectionqubit = before_down;
                }						                }
                else if ( (whatcorrection == next) && ( v_dir	                else if ( (whatcorrection == next) && ( v_dir
                {						                {
                    whatcorrectionqubit = next_up;		                    whatcorrectionqubit = next_up;
                }						                }
                else if ( (whatcorrection == next) && ( v_dir	                else if ( (whatcorrection == next) && ( v_dir
                {						                {
                    whatcorrectionqubit = next_down;		                    whatcorrectionqubit = next_down;
                }						                }
                else if ( (whatcorrection == four) && ( v_dir	                else if ( (whatcorrection == four) && ( v_dir
                {						                {
                    whatcorrectionqubit = four_up;		                    whatcorrectionqubit = four_up;
                }						                }
                else if ( (whatcorrection == four) && ( v_dir	                else if ( (whatcorrection == four) && ( v_dir
                {						                {
                    whatcorrectionqubit = four_down;		                    whatcorrectionqubit = four_down;
                }						                }
                else						                else
                {						                {
                    assert(0);					                    assert(0);
                }						                }

                if(debug4)					                if(debug4)
                {						                {
                    if (first)					                    if (first)
                    {						                    {
                        cout<< " first ";			                        cout<< " first ";
                    }						                    }
                    else					                    else
                    {						                    {
                        cout<<" not first ";			                        cout<<" not first ";
                    }						                    }
                    if (last)					                    if (last)
                    {						                    {
                        cout<< " last ";			                        cout<< " last ";
                    }						                    }
                    else					                    else
                    {						                    {
                        cout<<" not last ";			                        cout<<" not last ";
                    }						                    }

                    if (whatcorrectionqubit == before_up)	                    if (whatcorrectionqubit == before_up)
                    {						                    {
                        cout<< " before_up ";			                        cout<< " before_up ";
                    }						                    }
                    else if (whatcorrectionqubit == before_do	                    else if (whatcorrectionqubit == before_do
                    {						                    {
                        cout<< " before_down ";			                        cout<< " before_down ";
                    }						                    }
                    else if(whatcorrectionqubit == next_up)	                    else if(whatcorrectionqubit == next_up)
                    {						                    {
                        cout<< " next_up ";			                        cout<< " next_up ";
                    }						                    }
                    else if(whatcorrectionqubit == next_down)	                    else if(whatcorrectionqubit == next_down)
                    {						                    {
                        cout<< " next_down ";			                        cout<< " next_down ";
                    }						                    }
                    else if(whatcorrectionqubit == four_up)	                    else if(whatcorrectionqubit == four_up)
                    {						                    {
                        cout<< " four_up ";			                        cout<< " four_up ";
                    }						                    }
                    else if(whatcorrectionqubit == four_down)	                    else if(whatcorrectionqubit == four_down)
                    {						                    {
                        cout<< " four_down ";			                        cout<< " four_down ";
                    }						                    }
                    else					                    else
                    {						                    {
                        assert(0);				                        assert(0);
                    }						                    }
                }						                }




                switch (whatcorrectionqubit)			                switch (whatcorrectionqubit)
                {						                {
                case before_up:					                case before_up:
                    correct(x1,(Y+ySize-1)%ySize, 2);		                    correct(x1,(Y+ySize-1)%ySize, 2);
                    Y = (Y+1)%ySize;				                    Y = (Y+1)%ySize;
                    break;					                    break;


                case before_down:				                case before_down:
                    correct(x1,(Y+ySize-1)%ySize, 4);		                    correct(x1,(Y+ySize-1)%ySize, 4);
                    Y = (Y+1)%ySize;				                    Y = (Y+1)%ySize;
                    break;					                    break;
                case next_up:					                case next_up:
                    correct(x1,(Y+1)%ySize, 1);			                    correct(x1,(Y+1)%ySize, 1);
                    Y = (Y+1)%ySize;				                    Y = (Y+1)%ySize;
                    break;					                    break;
                case next_down:					                case next_down:
                    correct(x1,(Y+1)%ySize, 3);			                    correct(x1,(Y+1)%ySize, 3);
                    Y = (Y+1)%ySize;				                    Y = (Y+1)%ySize;
                    break;					                    break;
                case four_down:					                case four_down:
                    correct(x1,(Y+ySize-1)%ySize, 4);		                    correct(x1,(Y+ySize-1)%ySize, 4);
                    correct((x1+1)%xSize,Y, 1);			                    correct((x1+1)%xSize,Y, 1);
                    correct((x1+1)%xSize,Y, 2);			                    correct((x1+1)%xSize,Y, 2);
                    correct(x1,(Y+1)%ySize, 3);			                    correct(x1,(Y+1)%ySize, 3);
                    Y = (Y+1)%ySize;				                    Y = (Y+1)%ySize;
                    break;					                    break;
                case four_up:					                case four_up:
                    correct(x1,(Y+ySize-1)%ySize, 2);		                    correct(x1,(Y+ySize-1)%ySize, 2);
                    correct((x1+xSize-1)%ySize,Y, 3);		                    correct((x1+xSize-1)%ySize,Y, 3);
                    correct((x1+xSize-1)%ySize,Y, 4);		                    correct((x1+xSize-1)%ySize,Y, 4);
                    correct(x1,(Y+1)%ySize, 1);			                    correct(x1,(Y+1)%ySize, 1);
                    Y = (Y+1)%ySize;				                    Y = (Y+1)%ySize;
                    break;					                    break;
                default:					                default:
                    assert(0);					                    assert(0);
                }						                }

                //if we were at an octagon it shure must have	                //if we were at an octagon it shure must have
                // (otherwise assert(0);)-->so counter up!	                // (otherwise assert(0);)-->so counter up!
                l++;						                l++;

            }							            }
            else if ( which_cell_type(x1,Y) == sqr )		            else if ( which_cell_type(x1,Y) == sqr )
            {							            {

                Y = (Y+1)%ySize;				                Y = (Y+1)%ySize;

            }							            }
            else						            else
            {							            {
                assert(0);					                assert(0);
            }// end if octo or square				            }// end if octo or square

            // this makes the loop run a last time after Y hi	            // this makes the loop run a last time after Y hi
            // No, I do not want to talk about it!		            // No, I do not want to talk about it!
            if (exitnextloop)					            if (exitnextloop)
            {							            {
                exit = true;					                exit = true;
            }							            }
            if (Y == y2)					            if (Y == y2)
            {							            {
                exitnextloop = true;				                exitnextloop = true;
            }							            }




        } //endofwhileY						        } //endofwhileY
    }//endofifdeltay						    }//endofifdeltay


/////////////////////////////////////////////VERTICAL		/////////////////////////////////////////////VERTICAL
    // correct in the vertical direction			    // correct in the vertical direction
//Qubits to correct in vertical x Achsis			//Qubits to correct in vertical x Achsis
// go from x1|y2 to x2|y2					// go from x1|y2 to x2|y2
// x1 --> x2							// x1 --> x2


// use correct( x1, y1, qubitcorr)				// use correct( x1, y1, qubitcorr)

    //do we even need to correct in vertical direction?		    //do we even need to correct in vertical direction?
    if (delta_x != 0)						    if (delta_x != 0)
    {								    {
        //then start correction					        //then start correction

        //exitvariable						        //exitvariable
        bool exit = false;					        bool exit = false;
        //exit next time variable				        //exit next time variable
        bool exitnextloop = false;				        bool exitnextloop = false;

        //laufvariable						        //laufvariable
        int X = x1;						        int X = x1;
        //countingvariable counting the amount of corrections	        //countingvariable counting the amount of corrections
        int l = 1;						        int l = 1;

        // while exit is false					        // while exit is false
        while (!exit)						        while (!exit)
        {							        {

            //only if on an octagon				            //only if on an octagon
            if ( which_cell_type(X,y2) == octo)			            if ( which_cell_type(X,y2) == octo)
            {							            {


                //initialize that stuff				                //initialize that stuff
                bool first = false;				                bool first = false;
                bool last = false;				                bool last = false;
                correctiontype whatcorrection = wrong_correct	                correctiontype whatcorrection = wrong_correct
                correctiontypeQB whatcorrectionqubit = wrong_	                correctiontypeQB whatcorrectionqubit = wrong_



                //check if first				                //check if first
                if ( l == 1)					                if ( l == 1)
                {						                {
                    first = true;				                    first = true;
                }						                }
                //check if last					                //check if last
                if ( delta_xy(X,x2,xSize) <= 1 )		                if ( delta_xy(X,x2,xSize) <= 1 )
                {						                {
                    last = true;				                    last = true;
                }						                }

                //Determine correctiontype			                //Determine correctiontype
                if ( last && v_end_type == octo )		                if ( last && v_end_type == octo )
                {						                {
                    whatcorrection = before;			                    whatcorrection = before;
                }						                }
                else if (first && v_start_type)			                else if (first && v_start_type)
                {						                {
                    whatcorrection = next;			                    whatcorrection = next;
                }						                }
                else						                else
                {						                {
                    whatcorrection = four;			                    whatcorrection = four;
                }						                }

                //Determine correctiontypequbit			                //Determine correctiontypequbit

                if ( (whatcorrection == before) && ( v_dir ==	                if ( (whatcorrection == before) && ( v_dir ==
                {						                {
                    whatcorrectionqubit = before_up;		                    whatcorrectionqubit = before_up;
                }						                }
                else if ( (whatcorrection == before) && ( v_d	                else if ( (whatcorrection == before) && ( v_d
                {						                {
                    whatcorrectionqubit = before_down;		                    whatcorrectionqubit = before_down;
                }						                }
                else if ( (whatcorrection == next) && ( v_dir	                else if ( (whatcorrection == next) && ( v_dir
                {						                {
                    whatcorrectionqubit = next_up;		                    whatcorrectionqubit = next_up;
                }						                }
                else if ( (whatcorrection == next) && ( v_dir	                else if ( (whatcorrection == next) && ( v_dir
                {						                {
                    whatcorrectionqubit = next_down;		                    whatcorrectionqubit = next_down;
                }						                }
                else if ( (whatcorrection == four) && ( v_dir	                else if ( (whatcorrection == four) && ( v_dir
                {						                {
                    whatcorrectionqubit = four_up;		                    whatcorrectionqubit = four_up;
                }						                }
                else if ( (whatcorrection == four) && ( v_dir	                else if ( (whatcorrection == four) && ( v_dir
                {						                {
                    whatcorrectionqubit = four_down;		                    whatcorrectionqubit = four_down;
                }						                }
                else						                else
                {						                {
                    assert(0);					                    assert(0);
                }						                }





                switch (whatcorrectionqubit)			                switch (whatcorrectionqubit)
                {						                {
                case before_up:					                case before_up:
                    correct((X+xSize+1)%xSize,y2, 1);		                    correct((X+xSize+1)%xSize,y2, 1);
                    X = (X+xSize-1)%xSize;			                    X = (X+xSize-1)%xSize;
                    break;					                    break;
                case before_down:				                case before_down:
                    correct((X+xSize-1)%xSize,y2, 3);		                    correct((X+xSize-1)%xSize,y2, 3);
                    X = (X+1)%xSize;				                    X = (X+1)%xSize;
                    break;					                    break;
                case next_up:					                case next_up:
                    correct((X+xSize-1)%xSize,y2, 3);		                    correct((X+xSize-1)%xSize,y2, 3);
                    X = (X+xSize-1)%xSize;			                    X = (X+xSize-1)%xSize;
                    break;					                    break;
                case next_down:					                case next_down:
                    correct((X+xSize+1)%xSize,y2, 1);		                    correct((X+xSize+1)%xSize,y2, 1);
                    X = (X+1)%xSize;				                    X = (X+1)%xSize;
                    break;					                    break;
                case four_down:					                case four_down:
                    correct((X+xSize-1)%xSize,y2, 3);		                    correct((X+xSize-1)%xSize,y2, 3);
                    correct(X,(y2+ySize-1)%ySize, 2);		                    correct(X,(y2+ySize-1)%ySize, 2);
                    correct(X,(y2+ySize-1)%ySize, 4);		                    correct(X,(y2+ySize-1)%ySize, 4);
                    correct((X+xSize+1)%xSize,y2, 1);		                    correct((X+xSize+1)%xSize,y2, 1);
                    X = (X+1)%xSize;				                    X = (X+1)%xSize;
                    break;					                    break;
                case four_up:					                case four_up:
                    correct((X+xSize-1)%xSize,y2, 3);		                    correct((X+xSize-1)%xSize,y2, 3);
                    correct(X,(y2+ySize-1)%ySize, 2);		                    correct(X,(y2+ySize-1)%ySize, 2);
                    correct(X,(y2+ySize-1)%ySize, 4);		                    correct(X,(y2+ySize-1)%ySize, 4);
                    correct((X+xSize+1)%xSize,y2, 1);		                    correct((X+xSize+1)%xSize,y2, 1);
                    X = (X+xSize-1)%xSize;			                    X = (X+xSize-1)%xSize;
                    break;					                    break;
                default:					                default:
                    assert(0);					                    assert(0);
                }						                }

                //if we were at an octagon it shure must have	                //if we were at an octagon it shure must have
                // (otherwise assert(0);)-->so counter up!	                // (otherwise assert(0);)-->so counter up!
                l++;						                l++;

            }							            }
            else if ( which_cell_type(X,y2) == sqr )		            else if ( which_cell_type(X,y2) == sqr )
            {							            {

                switch (v_dir)					                switch (v_dir)
                {						                {
                case up:					                case up:
                    X = (X+xSize-1)%xSize;			                    X = (X+xSize-1)%xSize;
                    break;					                    break;
                case down:					                case down:
                    X = (X+1)%xSize;				                    X = (X+1)%xSize;
                    break;					                    break;
                case neither:					                case neither:
                    assert(0);					                    assert(0);
                default:					                default:
                    assert(0);					                    assert(0);
                }						                }


            }							            }
            else						            else
            {							            {
                assert(0);					                assert(0);
            }// end if octo or square				            }// end if octo or square


            // this makes the loop run a last time after X hi	            // this makes the loop run a last time after X hi
            // No, I do not want to talk about it!		            // No, I do not want to talk about it!
            if (exitnextloop)					            if (exitnextloop)
            {							            {
                exit = true;					                exit = true;
            }							            }
            if (X == x2)					            if (X == x2)
            {							            {
                exitnextloop = true;				                exitnextloop = true;
            }							            }




        } //endofwhileY						        } //endofwhileY
    }//endofifdeltax						    }//endofifdeltax


}// end of function I guess...					}// end of function I guess...




// Determines if we need to go up, down or neither in the lat	// Determines if we need to go up, down or neither in the lat
vertical_direction Lattice::v_where_to_go (int x1, int x2)	vertical_direction Lattice::v_where_to_go (int x1, int x2)
{								{

    vertical_direction v_dir = wrong_direction;			    vertical_direction v_dir = wrong_direction;

    if ( (x1 < x2 && x2 - x1 <  xSize - x2 + x1) ||		    if ( (x1 < x2 && x2 - x1 <  xSize - x2 + x1) ||
            (x2 < x1 && x1 - x2 >  xSize - x1 + x2) )		            (x2 < x1 && x1 - x2 >  xSize - x1 + x2) )
        v_dir = down;						        v_dir = down;
    else if (x1 == x2)						    else if (x1 == x2)
        v_dir = neither;					        v_dir = neither;
    else							    else
        v_dir = up;						        v_dir = up;

    return v_dir;						    return v_dir;
}								}




// Determines if the celltype is square or an octagon		// Determines if the celltype is square or an octagon
celltype Lattice::which_cell_type ( int x, int y)		celltype Lattice::which_cell_type ( int x, int y)
{								{

    int i = x;							    int i = x;
    int j = y;							    int j = y;

    celltype type = wrong_type;					    celltype type = wrong_type;

    if ( (i%2 && j%2)  || (!(i%2) && !(j%2)) )			    if ( (i%2 && j%2)  || (!(i%2) && !(j%2)) )
    {								    {
        type = octo;						        type = octo;
    }								    }
    else if ( (!(i%2) && j%2)  || (i%2 && !(j%2)) )		    else if ( (!(i%2) && j%2)  || (i%2 && !(j%2)) )
    {								    {
        type = sqr;						        type = sqr;
    }								    }
    else							    else
    {								    {
        type = wrong_type;					        type = wrong_type;
    }								    }

    return type;						    return type;

}//end of which_cell_type					}//end of which_cell_type



//determines distance between coordinates in x direction	//determines distance between coordinates in x direction
int Lattice::delta_xy(int xy1, int xy2, int Size)		int Lattice::delta_xy(int xy1, int xy2, int Size)
{								{

    int d = min (abs(xy2-xy1), Size-abs(xy2-xy1) );		    int d = min (abs(xy2-xy1), Size-abs(xy2-xy1) );

    return d;							    return d;

}//endof delta_x						}//endof delta_x



//returns true if there is no error syndrome anywhere on the 	//returns true if there is no error syndrome anywhere on the 

bool Lattice::is_line()						bool Lattice::is_line()
{								{


    bool is_line_var = false;					    bool is_line_var = false;
    int syndromecounter = 0;					    int syndromecounter = 0;


    // Identify vertices that represent squares/octagons with	    // Identify vertices that represent squares/octagons with


    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            bool syndrome = false;				            bool syndrome = false;
// if i,j both odd do OCT-Z-syndrome (detects X Errors)		// if i,j both odd do OCT-Z-syndrome (detects X Errors)

            if ( ((i%2) && (j%2)) )				            if ( ((i%2) && (j%2)) )
            {							            {
                syndrome = OCTsyndromeZZZZZZZZ(i,j);	      |	                // syndrome = OCTsyndromeZZZZZZZZ(i,j);
            }							            }
//if exactly  one of i and j is odd and one is even do SQ-Z-S	//if exactly  one of i and j is odd and one is even do SQ-Z-S

            if (  (i%2 && !(j%2))   ||   (!(i%2) && j%2) )	            if (  (i%2 && !(j%2))   ||   (!(i%2) && j%2) )
            {							            {
                syndrome = SQsyndromeZZZZ(i,j);		      |	                //syndrome = SQsyndromeZZZZ(i,j);
            }							            }


// if one of the above has a syndrome				// if one of the above has a syndrome
            if (syndrome)					            if (syndrome)
            {							            {
                syndromecounter++;				                syndromecounter++;
            }							            }
//otherwise go further						//otherwise go further
        }							        }
    }								    }

    if (syndromecounter == 2)					    if (syndromecounter == 2)
    {								    {
        is_line_var = true;					        is_line_var = true;
    }								    }


    return is_line_var;						    return is_line_var;


}								}




//generates exactly 1 line of errors on the lattice		//generates exactly 1 line of errors on the lattice

void Lattice::generateline()					void Lattice::generateline()
{								{
    int x1 =  -1;						    int x1 =  -1;
    int y1 = -1;						    int y1 = -1;

    int x2 =  -1;						    int x2 =  -1;
    int y2 = -1;						    int y2 = -1;




    while(true)							    while(true)
    {								    {

        x1 =  rand()%xSize;	//element [0,xSize]		        x1 =  rand()%xSize;	//element [0,xSize]
        y1 = rand()%ySize;	//element [0,ySize]		        y1 = rand()%ySize;	//element [0,ySize]

        x2 =  rand()%xSize;	//element [0,xSize]		        x2 =  rand()%xSize;	//element [0,xSize]
        y2 = rand()%ySize;	//element [0,ySize]		        y2 = rand()%ySize;	//element [0,ySize]

        //no syndrome at X Octagons erlaubt			        //no syndrome at X Octagons erlaubt
        if ( (!(x1%2) && !(y1%2)) || (!(x2%2) && !(y2%2)))	        if ( (!(x1%2) && !(y1%2)) || (!(x2%2) && !(y2%2)))
        {							        {
            continue;						            continue;
        }							        }



        //if we have generated two different points stop the 	        //if we have generated two different points stop the 
        if ((x1 != x2 || y1 != y2)    )				        if ((x1 != x2 || y1 != y2)    )
        {							        {
            break;						            break;
        }							        }

    }								    }




    correctLine( x1, y1, x2, y2);				    correctLine( x1, y1, x2, y2);


}//end of generateline						}//end of generateline



//returns true if there is no error syndrome anywhere on the 	//returns true if there is no error syndrome anywhere on the 

bool Lattice::is_corrected()					bool Lattice::is_corrected()
{								{



    // Identify vertices that represent squares/octagons with	    // Identify vertices that represent squares/octagons with


    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            bool syndrome = false;				            bool syndrome = false;
// if i,j both odd do OCT-Z-syndrome (detects X Errors)		// if i,j both odd do OCT-Z-syndrome (detects X Errors)

            if ( ((i%2) && (j%2)) )				            if ( ((i%2) && (j%2)) )
            {							            {
                syndrome = OCTsyndromeZZZZZZZZ(i,j);	      |	                syndrome = OCTsyndromeZZZZZZZZ(i,j,0);
            }							            }
//if exactly  one of i and j is odd and one is even do SQ-Z-S	//if exactly  one of i and j is odd and one is even do SQ-Z-S

            if (  (i%2 && !(j%2))   ||   (!(i%2) && j%2) )	            if (  (i%2 && !(j%2))   ||   (!(i%2) && j%2) )
            {							            {
                syndrome = SQsyndromeZZZZ(i,j);		      |	                syndrome = SQsyndromeZZZZ(i,j,0);
            }							            }


// if one of the above has a syndrome				// if one of the above has a syndrome
            if (syndrome)					            if (syndrome)
            {							            {
                return false;					                return false;
            }							            }
//otherwise go further						//otherwise go further
        }							        }
    }								    }



//if there was no syndrome anywhere				//if there was no syndrome anywhere
    return true;						    return true;


}								}







// Generates logical operator  Z1, or Z2 on this lattice whic	// Generates logical operator  Z1, or Z2 on this lattice whic
Operator* Lattice::getLogical(string whichOp)			Operator* Lattice::getLogical(string whichOp)
{								{

    //number of qubits						    //number of qubits
    Operator *myOp = new Operator (xSize*ySize/2*4);		    Operator *myOp = new Operator (xSize*ySize/2*4);

    for (int i = 0, l = 0; i < xSize; i++)			    for (int i = 0, l = 0; i < xSize; i++)
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            for (int k = 0; k < zSize; k++)			            for (int k = 0; k < zSize; k++)
            {							            {

                if ( which_cell_type(i,j) == octo || (k == 0)	                if ( which_cell_type(i,j) == octo || (k == 0)
                {						                {
                    if(debug8)					                    if(debug8)
                    {						                    {
                        cout<<"continue"<<endl;			                        cout<<"continue"<<endl;
                    }						                    }
                    continue;					                    continue;

                }						                }

                if (whichOp == "Z1")				                if (whichOp == "Z1")
                {						                {
                    //first line squares			                    //first line squares
                    if (((i == 0) && which_cell_type(i,j) == 	                    if (((i == 0) && which_cell_type(i,j) == 
                    {						                    {
                        if(debug8)				                        if(debug8)
                        {					                        {
                            cout<<"Z"<<endl;			                            cout<<"Z"<<endl;
                        }					                        }
                        myOp->ops[l] = Z;			                        myOp->ops[l] = Z;
                    }						                    }
                    else					                    else
                    {						                    {
                        if(debug8)				                        if(debug8)
                        {					                        {
                            cout<<"I"<<endl;			                            cout<<"I"<<endl;
                        }					                        }
                        myOp->ops[l] = I;			                        myOp->ops[l] = I;
                    }						                    }
                }						                }
                else if (whichOp == "Z2")			                else if (whichOp == "Z2")
                {						                {
                    //first column squares			                    //first column squares
                    if ((j == 0 && which_cell_type(i,j) == sq	                    if ((j == 0 && which_cell_type(i,j) == sq
                    {						                    {
                        if(debug8)				                        if(debug8)
                        {					                        {
                            cout<<"Z"<<endl;			                            cout<<"Z"<<endl;
                        }					                        }
                        myOp->ops[l] = Z;			                        myOp->ops[l] = Z;
                    }						                    }
                    else					                    else
                    {						                    {
                        if(debug8)				                        if(debug8)
                        {					                        {
                            cout<<"I"<<endl;			                            cout<<"I"<<endl;
                        }					                        }
                        myOp->ops[l] = I;			                        myOp->ops[l] = I;
                    }						                    }
                }						                }
                else						                else
                {						                {
                    assert (0);					                    assert (0);
                }						                }
                l++;						                l++;

            }//endofk						            }//endofk
        }//endofj						        }//endofj
    }//endofi							    }//endofi

    return myOp;						    return myOp;
}								}


// Examimes ErrInit and ErrGuess to determine if error correc	// Examimes ErrInit and ErrGuess to determine if error correc
// Multiplies ErrGuess with operator p.				// Multiplies ErrGuess with operator p.
bool Lattice::success(Operator *p)			      |	bool Lattice::success(void)
{								{

    // Calculate O = E * E_guessed				    // Calculate O = E * E_guessed
    Operator E(0), EGuessP(0);					    Operator E(0), EGuessP(0);
    for (int i = 0, l = 0; i < xSize; i++)		      |	    for (int i = 0; i < xSize; i++)
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            for (int k = 0; k < zSize; k++)			            for (int k = 0; k < zSize; k++)
            {							            {
                if ((i%2 && j%2) || (!(i%2) && !(j%2)) || (k  |	                if ((k == 0) || (i%2 && j%2) || (!(i%2) && !(
                {						                {
                    continue;					                    continue;
                }						                }

                E.pushBack (cells[i][j][k]->ErrInit->ops[0]);	                E.pushBack (cells[i][j][k]->ErrInit->ops[0]);
                if (p)					      |	                EGuessP.pushBack (cells[i][j][k]->ErrGuess->o
                {					      |	                //ECurrent.pushBack (cells[i][j]->ErrCurrent-
                    pauli pErrGuessP = cells[i][j][k]->ErrGue <
                    EGuessP.pushBack (pErrGuessP);	      <
                }					      <
                else					      <
                {					      <
                    EGuessP.pushBack (cells[i][j][k]->ErrGues <
                }					      <
            }							            }
        }							        }
    }								    }
    Operator O = E * EGuessP;					    Operator O = E * EGuessP;

							      >	    /*
							      >	    	Debug
							      >
							      >	      Operator  ECurrent(0);
							      >	      //O and ECurrent should be the same
							      >	    	cout<<endl<<"E: ";
							      >	    	E.printState();
							      >	    	cout<<endl<<"G: ";
							      >	    	EGuessP.printState();
							      >	    	cout<<endl<<"O: ";
							      >	    	O.printState();
							      >	    	cout<<endl<<"C: ";
							      >	    	ECurrent.printState();
							      >	    	cout<<endl<<endl;
							      >	    */
							      >
    // Generate logical operators  Z1, Z2			    // Generate logical operators  Z1, Z2

    Operator *Z1 = getLogical("Z1");				    Operator *Z1 = getLogical("Z1");
    Operator *Z2 = getLogical("Z2");				    Operator *Z2 = getLogical("Z2");

    assert ( Z1->commute(*Z2));					    assert ( Z1->commute(*Z2));
    if (debug7)							    if (debug7)
    {								    {
        cout<<"E0: ";						        cout<<"E0: ";
        E.printState();						        E.printState();
        cout<<endl;						        cout<<endl;
        cout<<"EG: ";						        cout<<"EG: ";
        EGuessP.printState();					        EGuessP.printState();
        cout<<endl;						        cout<<endl;
        cout<<"Ob: ";						        cout<<"Ob: ";
        O.printState();						        O.printState();
        cout<<endl;						        cout<<endl;
        cout<<"Z1: ";						        cout<<"Z1: ";
        Z1->printState();					        Z1->printState();
        cout<<endl;						        cout<<endl;

    }								    }

    // Determine result of error correction			    // Determine result of error correction
    bool result = true;						    bool result = true;
    if ( !O.commute(*Z1) || !O.commute(*Z2) )		      |	//if ( !O.commute(*Z1) || !O.commute(*Z2) ) {
							      >	    if ( !O.commute(*Z2)  )
    {								    {
        result = false;						        result = false;
    }								    }

    delete Z1;							    delete Z1;
    delete Z2;							    delete Z2;

    return result;						    return result;

//der 2. Z muss noch weg dann				      |
    return true;					      |	}
							      >
							      >
							      >	// Print the current 2Dstate of the lattice. The content of E
							      >	void Lattice::print2DState(void)
							      >	{
							      >
							      >	    for (int i = 0; i < xSize; i++)
							      >	    {
							      >	        for (int j = 0; j < ySize; j++)
							      >	        {
							      >
							      >
							      >
							      >
							      >	            if (i==1 && !(j%2))  //j=1,3,5is syndrome,0,2,4 i
							      >	            {
							      >	                cells[i][j][1]->ErrCurrent->printState();
							      >	                if (SQsyndromeZZZZ (i, j, 0))
							      >	                {
							      >	                    cout<<"-";
							      >	                }
							      >	                else
							      >	                {
							      >	                    cout<<"+";
							      >	                }
							      >	                cells[i][j][2]->ErrCurrent->printState();
							      >
							      >	            }
							      >	            else if (i==1 && j%2)
							      >	            {
							      >	                if (OCTsyndromeZZZZZZZZ (i, j, 0))
							      >	                {
							      >	                    cout<<" - ";
							      >	                }
							      >	                else
							      >	                {
							      >	                    cout<<" + ";
							      >	                }
							      >	            }
							      >
							      >	        }//endofj
							      >	    }//endofi
							      >	    cout<<endl;
}								}



							      >
							      >
							      >
// Print the current state of the lattice. The content of Err	// Print the current state of the lattice. The content of Err
void Lattice::printState(void)					void Lattice::printState(void)
{								{

    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            for (int k = 0; k < zSize; k++)			            for (int k = 0; k < zSize; k++)
            {							            {
                if ((k == 0) || (i%2 && j%2) || (!(i%2) && !(	                if ((k == 0) || (i%2 && j%2) || (!(i%2) && !(
                    continue;					                    continue;
                cout << "Error at location X=" << i << " Y=" 	                cout << "Error at location X=" << i << " Y=" 
                cells[i][j][k]->ErrCurrent->printState();	                cells[i][j][k]->ErrCurrent->printState();
                cout<< endl;					                cout<< endl;
            }							            }
        }							        }
    }								    }
}								}

// Print the current state of the QB lattice. The content of 	// Print the current state of the QB lattice. The content of 
void Lattice::printStateQB(void)				void Lattice::printStateQB(void)
{								{
    cout<<"Print Lattice State"<<endl;				    cout<<"Print Lattice State"<<endl;

    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
        for (int l = 0; l < 3; l++)				        for (int l = 0; l < 3; l++)
        {							        {
            for (int j = 0; j < ySize; j++)			            for (int j = 0; j < ySize; j++)
            {							            {

                if ( (i%2 && j%2) || (!(i%2) && !(j%2)))	                if ( (i%2 && j%2) || (!(i%2) && !(j%2)))
                {						                {

                    if (l==1)					                    if (l==1)
                    {						                    {
                        if(i%2 && j%2)				                        if(i%2 && j%2)
                        {					                        {
                            cout<< "    ";			                            cout<< "    ";
                            // if there is syndrome print -	                            // if there is syndrome print -
                            if(OCTsyndromeZZZZZZZZ(i,j))      |	                            //if(OCTsyndromeZZZZZZZZ(i,j)){co
                            {				      <
                                cout<<"-";		      <
                            }				      <
                            else			      <
                            {				      <
                                cout<<"+";		      <
                            }				      <
                            cout<<"    ";			                            cout<<"    ";
                            continue;				                            continue;
                        }					                        }
                        else					                        else
                        {					                        {
                            cout<< "         ";			                            cout<< "         ";
                            continue;				                            continue;
                        }					                        }

                    }						                    }
                    else					                    else
                    {						                    {
                        cout<< "         ";			                        cout<< "         ";
                        continue;				                        continue;
                    }						                    }
                }						                }



                if (l==0)					                if (l==0)
                {						                {
                    cout<<" ";					                    cout<<" ";
                    cells[i][j][1]->ErrCurrent->printState();	                    cells[i][j][1]->ErrCurrent->printState();
                    cout<<" --- ";				                    cout<<" --- ";
                    cells[i][j][2]->ErrCurrent->printState();	                    cells[i][j][2]->ErrCurrent->printState();
                    cout<<" ";					                    cout<<" ";


                }						                }
                else if (l==1)					                else if (l==1)
                {						                {
                    cout<<"  | ";				                    cout<<"  | ";
                    //if there is syndrome print -		                    //if there is syndrome print -
                    if(SQsyndromeZZZZ(i,j))		      |	                    //if(SQsyndromeZZZZ(i,j)){cout<<"-";} els
                    {					      <
                        cout<<"-";			      <
                    }					      <
                    else				      <
                    {					      <
                        cout<<"+";			      <
                    }					      <
                    cout <<" |  ";				                    cout <<" |  ";
                }						                }
                else if (l==2)					                else if (l==2)
                {						                {
                    cout<<" ";					                    cout<<" ";
                    cells[i][j][3]->ErrCurrent->printState();	                    cells[i][j][3]->ErrCurrent->printState();
                    cout<<" --- ";				                    cout<<" --- ";
                    cells[i][j][4]->ErrCurrent->printState();	                    cells[i][j][4]->ErrCurrent->printState();
                    cout<<" ";					                    cout<<" ";
                }						                }










            }//end of j						            }//end of j
            cout<<endl;						            cout<<endl;
        }// end of l						        }// end of l
        cout<<endl;						        cout<<endl;



    }//end of i							    }//end of i
}//end of print							}//end of print






							      >	//end of file lattice.cc
