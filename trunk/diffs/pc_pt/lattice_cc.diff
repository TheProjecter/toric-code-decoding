#include "lattice.h"						#include "lattice.h"
#include "constants.h"						#include "constants.h"


// Constructor generates a unit cell. In case of the surface 	// Constructor generates a unit cell. In case of the surface 
Cell::Cell (double & p)						Cell::Cell (double & p)
{								{
    ErrInit    = new Operator (1);				    ErrInit    = new Operator (1);
    ErrInit->generateRandom (p);				    ErrInit->generateRandom (p);
    // ErrCurrent is a copy of the random ErrInit		    // ErrCurrent is a copy of the random ErrInit
    ErrCurrent = new Operator (*ErrInit);			    ErrCurrent = new Operator (*ErrInit);
    ErrGuess   = new Operator (1);				    ErrGuess   = new Operator (1);

}								}


// Destructor for a unit cell.					// Destructor for a unit cell.
Cell::~Cell (void)						Cell::~Cell (void)
{								{
    delete ErrInit;						    delete ErrInit;
    delete ErrCurrent;						    delete ErrCurrent;
    delete ErrGuess;						    delete ErrGuess;
}								}


// Constructor of a vertex representing an operator in the tr	// Constructor of a vertex representing an operator in the tr
Vertex::Vertex (int newX, int newY)				Vertex::Vertex (int newX, int newY)
{								{
    x  = newX;							    x  = newX;
    y  = newY;							    y  = newY;
}								}


// Constructor generates the lattice.				// Constructor generates the lattice.
Lattice::Lattice(int newXSize, double p)			Lattice::Lattice(int newXSize, double p)
{								{

    xSize = 2*newXSize;						    xSize = 2*newXSize;
    ySize = 2*newXSize;						    ySize = 2*newXSize;

// zSize: 0 is the syndrome level, 1,2,3,4 are the qubit indi |	    cells = new Cell**[xSize];
    zSize = 5;						      <
							      <
    cells = new Cell***[xSize];				      <
    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
        cells[i] = new Cell**[ySize];			      |	        cells[i] = new Cell*[ySize];
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            cells[i][j] = new Cell *[zSize];		      |	//if i,j both odd     OR    both even DO NOT generate a new c
            for ( int k = 0; k < zSize; k++)		      |	            if ((i%2 && j%2) || (!(i%2) && !(j%2)))
            {							            {
                //if k= 0     OR  i,j both odd OR    both eve |	                continue;
                if ( k == 0 || (i%2 && j%2)  || (!(i%2) && !( |	            }
                {					      |	//otherwise, if only one of i,j is odd generate a new cell (q
                    continue;				      |	            cells[i][j] = new Cell (p);
                }					      |	        }
							      |	    }
                //otherwise, if only one of i,j is odd  and k <
                if(debug6)				      <
                {					      <
                    cout<< i<<j<<k<<" ";		      <
                }					      <
                cells[i][j][k] = new Cell (p);		      <
							      <
            }//end of k					      <
        }//end of j					      <
    }// end of i					      <


}								}


// Destructor of the lattice.					// Destructor of the lattice.
Lattice::~Lattice(void)						Lattice::~Lattice(void)
{								{

    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            for (int k = 0; k < zSize; k++)		      |	            if ((i%2 && j%2) || (!(i%2) && !(j%2)))
            {						      |	                continue;
                if ((k ==0) || (i%2 && j%2) || (!(i%2) && !(j |	            delete cells[i][j];
                    continue;				      <
                delete cells[i][j][k];			      <
            }						      <
            delete[] cells[i][j];			      <
        }							        }
        delete[] cells[i];					        delete[] cells[i];
    }								    }
    delete cells;						    delete cells;

}								}




// Calculates Octaeder plaquette syndrome at (around) the spe |	// Calculates plaquette syndrome at (around) the specified co
bool Lattice::OCTsyndromeZZZZZZZZ (int xLoc, int yLoc)	      |	bool Lattice::syndromeZZZZ (int xLoc, int yLoc)
{								{
//both i,j odd						      <
							      <
    /* Debug						      <
    cout<<" xLoc "<< xLoc <<"  xSize "<< xSize <<" yLoc  " << <

    */							      <
    assert (xLoc < xSize && yLoc < ySize && (xLoc % 2) && (yL	    assert (xLoc < xSize && yLoc < ySize && (xLoc % 2) && (yL

    bool result = false;					    bool result = false;

    Operator *P = new Operator(8);			      <
    P->ops[0]  = Z;					      <
    P->ops[1]  = Z;					      <
    P->ops[2]  = Z;					      <
    P->ops[3]  = Z;					      <
    P->ops[4]  = Z;					      <
    P->ops[5]  = Z;					      <
    P->ops[6]  = Z;					      <
    P->ops[7]  = Z;					      <
							      <
    Operator *plaquette = new Operator(8);		      <
							      <
//Remember QB are					      <
//1--2							      <
//|  |							      <
//3--4							      <
    //One step left (if i is line, y is column) to the square <
    plaquette->ops[0]  = cells[xLoc][(yLoc-1+ySize)%ySize][2] <
    plaquette->ops[1]  = cells[xLoc][(yLoc-1+ySize)%ySize][4] <
    //One step down get QB 1,2				      <
    plaquette->ops[2]  = cells[(xLoc+1)%xSize][yLoc][1]->ErrC <
    plaquette->ops[3]  = cells[(xLoc+1)%xSize][yLoc][2]->ErrC <
// One step right, get QB 1,3				      <
    plaquette->ops[4]  = cells[xLoc][(yLoc+1)%ySize][1]->ErrC <
    plaquette->ops[5]  = cells[xLoc][(yLoc+1)%ySize][3]->ErrC <
//One step up get QB 3,4				      <
    plaquette->ops[6]  = cells[(xLoc-1+xSize)%xSize][yLoc][3] <
    plaquette->ops[7]  = cells[(xLoc-1+xSize)%xSize][yLoc][4] <
							      <
    /* DEBUG						      <
    //test where the plaquette tests the cells		      <
    cout << "xLoc  " << xLoc << "    yLoc-1  " << yLoc-1 << e <
    cout << "xLoc+1modxSiyze  " << (xLoc+1)%xSize << "    yLo <
    cout << "xLoc  " << xLoc << "    yLoc+1modySize  " << (yL <
    cout << "xLoc-1  " << xLoc-1 <<"  yLoc  " << yLoc <<  end <
							      <
    */							      <
							      <
    result = !P->commute(*plaquette);			      <
							      <
    delete P;						      <
    delete plaquette;					      <
    return result;					      <
}							      <
							      <
// Calculates SQUARE plaquette syndrome at (around) the speci <
bool Lattice::SQsyndromeZZZZ (int xLoc, int yLoc)	      <
{							      <
//exactly one of i,j odd and one even			      <
    assert (xLoc < xSize && yLoc < ySize && ( ((xLoc % 2) &&  <
							      <
    bool result = false;				      <
							      <
    Operator *P = new Operator(4);				    Operator *P = new Operator(4);
    P->ops[0]  = Z;						    P->ops[0]  = Z;
    P->ops[1]  = Z;						    P->ops[1]  = Z;
    P->ops[2]  = Z;						    P->ops[2]  = Z;
    P->ops[3]  = Z;						    P->ops[3]  = Z;

							      <
    Operator *plaquette = new Operator(4);			    Operator *plaquette = new Operator(4);
							      |	    plaquette->ops[0]  = cells[xLoc][yLoc-1]->ErrCurrent->ops
//Remember QB are					      |	    plaquette->ops[1]  = cells[(xLoc+1)%xSize][yLoc]->ErrCurr
//1--2							      |	    plaquette->ops[2]  = cells[xLoc][(yLoc+1)%ySize]->ErrCurr
//|ij|							      |	    plaquette->ops[3]  = cells[xLoc-1][yLoc]->ErrCurrent->ops
//3--4							      <
    plaquette->ops[0]  = cells[xLoc][yLoc][1]->ErrCurrent->op <
    plaquette->ops[1]  = cells[xLoc][yLoc][2]->ErrCurrent->op <
    plaquette->ops[2]  = cells[xLoc][yLoc][3]->ErrCurrent->op <
    plaquette->ops[3]  = cells[xLoc][yLoc][4]->ErrCurrent->op <
							      <
							      <

    result = !P->commute(*plaquette);				    result = !P->commute(*plaquette);

    delete P;							    delete P;
    delete plaquette;						    delete plaquette;
    return result;						    return result;
}								}


// Calculates a signature which is a concatentation of all si	// Calculates a signature which is a concatentation of all si
vector<bool> Lattice::getSignature (void)			vector<bool> Lattice::getSignature (void)
{								{

    // The signature starts out empty				    // The signature starts out empty
    vector<bool> signature;					    vector<bool> signature;



    // Add ZZZZ syndromes					    // Add ZZZZ syndromes
    for (int i = 1; i < xSize; i+=2)				    for (int i = 1; i < xSize; i+=2)
    {								    {
        for (int j = 1; j < ySize; j+=2)			        for (int j = 1; j < ySize; j+=2)
        {							        {
            signature.push_back(SQsyndromeZZZZ(i,j));	      |	            signature.push_back(syndromeZZZZ(i,j));
        }							        }
    }								    }

    return signature;						    return signature;
}								}


//  Transform X or Z errors at the specified location.		//  Transform X or Z errors at the specified location.
void Lattice::correct ( int xLoc, int yLoc, int QubitNr)      |	void Lattice::correct ( int xLoc, int yLoc)
{								{
    if (debug4)						      <
    {							      <
        cout<< "xsize,ysixze,ysize "<<xSize<<ySize<<zSize<<en <
        cout<< "xLoc,yLoc,QBNr "<<xLoc<<yLoc<<QubitNr<<endl;  <
    }							      <
    assert (xLoc < xSize && yLoc < ySize && QubitNr < zSize); <

							      >	    assert (xLoc < xSize && yLoc < ySize);
//X*X=I								//X*X=I
    pauli p = X;						    pauli p = X;

    // Correct the error					    // Correct the error
    cells[xLoc][yLoc][QubitNr]->ErrCurrent->ops[0] = cells[xL |	    cells[xLoc][yLoc]->ErrCurrent->ops[0] = cells[xLoc][yLoc]
    cells[xLoc][yLoc][QubitNr]->ErrGuess->ops[0] = cells[xLoc |	    cells[xLoc][yLoc]->ErrGuess->ops[0] = cells[xLoc][yLoc]->
							      <
    if (debug1)						      <
    {							      <
        cout << " -> correcting " << p << " at x=" << xLoc << <
    }							      <
    if (debug3)						      <
    {							      <
        cout << " -> correcting " << p << " at x=" << xLoc << <
    }							      <

}//end of correct()					      |	    if (debug1) cout << " -> correcting " << p << " at x=" <<
							      >	}


// Calls the mathcing algorithm to find pairs of squares with	// Calls the mathcing algorithm to find pairs of squares with
// and calls the correction subroutine.				// and calls the correction subroutine.
void Lattice::correctMesh ()					void Lattice::correctMesh ()
{								{


    // Identify vertices that represent squares/octagons with |
							      >	    // Identify vertices that represent squares with non-triv
    vector<Vertex*> vertices;					    vector<Vertex*> vertices;

    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            bool syndrome = false;				            bool syndrome = false;
// if i,j both odd do OCT-Z-syndrome (detects X Errors)	      |	// if i,j both odd and mesh id 1 do Zsyndrome (detects X Erro
							      |	            if (i%2 && j%2 )
            if ( ((i%2) && (j%2)) )			      |	                syndrome = syndromeZZZZ(i,j);
            {						      <
                syndrome = OCTsyndromeZZZZZZZZ(i,j);	      <
            }						      <
//if exactly  one of i and j is odd and one is even do SQ-Z-S <
							      <
            if (  (i%2 && !(j%2))   ||   (!(i%2) && j%2) )    <
            {						      <
                syndrome = SQsyndromeZZZZ(i,j);		      <
            }						      <

            if (syndrome)					            if (syndrome)
            {							            {
                if (debug1) cout << "Syndrome:"  << " i=" << 	                if (debug1) cout << "Syndrome:"  << " i=" << 
                Vertex* v = new Vertex (i, j);			                Vertex* v = new Vertex (i, j);
                vertices.push_back(v);				                vertices.push_back(v);
            }							            }
        }							        }
    }								    }

    // Call minimum weight perfect matching			    // Call minimum weight perfect matching
    struct PerfectMatching::Options options;			    struct PerfectMatching::Options options;
    struct GeomPerfectMatching::GPMOptions gpm_options;		    struct GeomPerfectMatching::GPMOptions gpm_options;
    options.verbose = false;					    options.verbose = false;

    int numVert = vertices.size();				    int numVert = vertices.size();
    int edges = (numVert*(numVert-1));				    int edges = (numVert*(numVert-1));
    PerfectMatching *pm = new PerfectMatching(numVert,edges);	    PerfectMatching *pm = new PerfectMatching(numVert,edges);

    // Add all weighted edges (u,v) with weight w in complete	    // Add all weighted edges (u,v) with weight w in complete
    for (int i = 0; i < numVert; i++)				    for (int i = 0; i < numVert; i++)
    {								    {
        for (int j = 0; j < numVert; j++)			        for (int j = 0; j < numVert; j++)
        {							        {
            if (i == j)						            if (i == j)
                continue;					                continue;
            int deltaX = min (abs (vertices[i]->x - vertices[	            int deltaX = min (abs (vertices[i]->x - vertices[
            //if both syndromes are both on the same odd colu <
            //just a fancy specialty of this metrik (taxi-cab <
            if ( (vertices[i]->y == vertices[j]->y) && (!(ver <
            {						      <
                deltaX = deltaX + 2;			      <
            }						      <
							      <
            int deltaY = min (abs (vertices[i]->y - vertices[	            int deltaY = min (abs (vertices[i]->y - vertices[
            //if the syndromes are both on the same odd line  |	            int dist   = (deltaX + deltaY) / 2;
            //just a fancy specialty of this metrik (taxi-cab <
            if ( (vertices[i]->x == vertices[j]->x) && (!(ver <
            {						      <
                deltaY = deltaY + 2;			      <
            }						      <
            int dist   = (deltaX + deltaY);		      <
            pm->AddEdge(i,j,dist);				            pm->AddEdge(i,j,dist);
            if (debug1) cout << "Matching: i=" << i << " j= "	            if (debug1) cout << "Matching: i=" << i << " j= "
							      <
        }							        }
    }								    }

    pm->options = options;					    pm->options = options;
    pm->Solve();						    pm->Solve();

    // Call the correction subroutine for all matched vertice	    // Call the correction subroutine for all matched vertice
    for (int i = 0; i < numVert; i++ )				    for (int i = 0; i < numVert; i++ )
    {								    {
        // i and j are matched					        // i and j are matched
        int j = pm->GetMatch(i);				        int j = pm->GetMatch(i);
        if (i < j)						        if (i < j)
            //cout<<"correctline" <<vertices[i]->x<<" "<< ver <
            correctLine (vertices[i]->x, vertices[i]->y, vert	            correctLine (vertices[i]->x, vertices[i]->y, vert
    }								    }

    for (int i = 0; i < numVert; i++)				    for (int i = 0; i < numVert; i++)
    {								    {
        delete vertices[i];					        delete vertices[i];
    }								    }
    delete pm;							    delete pm;

}								}


// Given the locations of two syndromes with a non-trivial sy	// Given the locations of two syndromes with a non-trivial sy
// connecting the two syndromes.				// connecting the two syndromes.
void Lattice::correctLine ( int x1Loc, int y1Loc, int x2Loc, 	void Lattice::correctLine ( int x1Loc, int y1Loc, int x2Loc, 
{								{

    // Initialize x1, y1, x2, y2 so that we can correct error	    // Initialize x1, y1, x2, y2 so that we can correct error
    // the SE or SW direction coming from coordinates 1 to co	    // the SE or SW direction coming from coordinates 1 to co
							      <
//x y-->						      <
//I							      <
//v    EAST						      <
//  00 01 02						      <
//N 10 11 13 South					      <
//  20 21 22						      <
//  West						      <
							      <
    int x1, y1, x2, y2;						    int x1, y1, x2, y2;
    if ( (y1Loc < y2Loc && y2Loc - y1Loc < ySize - y2Loc + y1	    if ( (y1Loc < y2Loc && y2Loc - y1Loc < ySize - y2Loc + y1
            (y2Loc < y1Loc && y1Loc - y2Loc > ySize - y1Loc +	            (y2Loc < y1Loc && y1Loc - y2Loc > ySize - y1Loc +
    {								    {
        x1 = x1Loc;						        x1 = x1Loc;
        y1 = y1Loc;						        y1 = y1Loc;
        x2 = x2Loc;						        x2 = x2Loc;
        y2 = y2Loc;						        y2 = y2Loc;
    }								    }
    else							    else
    {								    {
        x1 = x2Loc;						        x1 = x2Loc;
        y1 = y2Loc;						        y1 = y2Loc;
        x2 = x1Loc;						        x2 = x1Loc;
        y2 = y1Loc;						        y2 = y1Loc;
    }								    }

// go from x1|y1 -> x2|y2				      |	    // Determine if we need to go to SE or SW
// y2 = y1+(...)%ySize					      |	    bool east;
							      <
//DIRECTION						      <
    // Determine if we need to go up, down or neither	      <
    vertical_direction v_dir = v_where_to_go(x1, x2);	      <
//up,down, neither, wrong_direction			      <
							      <
//HORIZONTAL Y-ACHSIS j					      <
    // Determine if we need to start from sqr or oct	      <
    celltype h_start_type = which_cell_type ( x1, y1);	      <
//sqr,oct,wrong_type					      <
    // Determine if we need to start from sqr or oct	      <
    celltype h_end_type = which_cell_type ( x1, y2);	      <
							      <
//VERTICAL X-ACHSIS i					      <
// Determine if we need to start from sqr or oct	      <
    celltype v_start_type = h_end_type;			      <
    // Determine if we need to start from sqr or oct	      <
    celltype v_end_type = which_cell_type ( x2, y2);	      <
							      <
//Determine distance between syndromes			      <
							      <
    int delta_x = delta_xy(x2,x1,xSize);		      <
    int delta_y = delta_xy(y2,y1,ySize);		      <
							      <
							      <
							      <
							      <
							      <
							      <
							      <
							      <
    /*old debugging					      <
      if (debug1) cout << "Correcting line x1=" << x1 << " y1 <
    */							      <
							      <
    if (debug3)						      <
    {							      <
        cout <<endl<< "Correcting line x1=" << x1 << " y1=" < <
             << " direction= ";				      <
        if (v_dir==up)					      <
        {						      <
            cout<< " up "<<endl;			      <
        }						      <
        else if (v_dir==down)				      <
        {						      <
            cout<< " down "<<endl;			      <
        }						      <
        else if (v_dir==neither)			      <
        {						      <
            cout<< " neither "<<endl;			      <
        }						      <
        cout<< "Start Horizontal= ";			      <
        if (h_start_type==sqr)				      <
        {						      <
            cout<< " square "<<endl;			      <
        }						      <
        else if (h_start_type==octo)			      <
        {						      <
            cout<< " 0ctogon "<<endl;			      <
        }						      <
        cout<< "End Horizontal= ";			      <
        if (h_end_type==sqr)				      <
        {						      <
            cout<< " square "<<endl;			      <
        }						      <
        else if (h_end_type==octo)			      <
        {						      <
            cout<< " 0ctogon "<<endl;			      <
        }						      <
        cout<< "Start Vertical= ";			      <
        if (v_start_type==sqr)				      <
        {						      <
            cout<< " square "<<endl;			      <
        }						      <
        else if (v_start_type==octo)			      <
        {						      <
            cout<< " 0ctogon "<<endl;			      <
        }						      <
        cout<< "End Vertical= ";			      <
        if (v_end_type==sqr)				      <
        {						      <
            cout<< " square "<<endl;			      <
        }						      <
        else if (v_end_type==octo)			      <
        {						      <
            cout<< " 0ctogon "<<endl;			      <
        }						      <
        cout<< "Delta_y= "<<delta_xy(y2,y1,ySize)<<endl;      <
        cout<< "Delta_x= "<<delta_xy(x2,x1,xSize)<<endl;      <
    }							      <
/////////////////////////////////////////////HORIZONTAL	      <
    // correct in the horizontal direction first	      <
//Qubits to correct in horizontal y Achsis		      <
//y1 ++ to y2						      <
							      <
							      <
// use correct( x1, y1, qubitcorr)			      <
							      <
    //do we need to correct in horizontal direction?	      <
    if (delta_y != 0)					      <
    {							      <
							      <
        if (debug4)					      <
        {						      <
            cout<<"delta_y != 0"<<endl;			      <
        }						      <
        //then start correction				      <
							      <
        //exitvariable					      <
        bool exit = false;				      <
        //exit next time variable			      <
        bool exitnextloop = false;			      <
							      <
							      <
        //laufvariable					      <
        int Y = y1;					      <
        //countingvariable counting the amount of corrections <
        int l = 1;					      <
							      <
        //while exit is false				      <
        while (!exit)					      <
        {						      <
							      <
            if (debug4)					      <
            {						      <
                cout<<"Y, y2: "<<Y<<" "<<y2<<endl;	      <
            }						      <
							      <
							      <
            //only if on an octagon			      <
            if ( which_cell_type(x1,Y) == octo)		      <
            {						      <
							      <
                if (debug4)				      <
                {					      <
                    cout<<" is octagon "<<endl;		      <
                }					      <
							      <
                //initialize the stuff!			      <
                bool first = false;			      <
                bool last = false;			      <
                correctiontype whatcorrection = wrong_correct <
                correctiontypeQB whatcorrectionqubit = wrong_ <
							      <
							      <
                //check if first			      <
                if ( l == 1)				      <
                {					      <
                    first = true;			      <
                }					      <
							      <
                //check if last				      <
                if ( delta_xy(Y,y2,ySize) <= 1 )	      <
                {					      <
                    last = true;			      <
                }					      <
							      <
                //Determine correctiontype		      <
                if ( last && h_end_type == octo )	      <
                {					      <
                    whatcorrection = before;		      <
                }					      <
                else if (first && h_start_type)		      <
                {					      <
                    whatcorrection = next;		      <
                }					      <
                else					      <
                {					      <
                    whatcorrection = four;		      <
                }					      <
							      <
                //Determine correctiontypequbit		      <
							      <
                if ( (whatcorrection == before) && ( v_dir == <
                {					      <
                    whatcorrectionqubit = before_up;	      <
                }					      <
                else if ( (whatcorrection == before) && ( v_d <
                {					      <
                    whatcorrectionqubit = before_down;	      <
                }					      <
                else if ( (whatcorrection == next) && ( v_dir <
                {					      <
                    whatcorrectionqubit = next_up;	      <
                }					      <
                else if ( (whatcorrection == next) && ( v_dir <
                {					      <
                    whatcorrectionqubit = next_down;	      <
                }					      <
                else if ( (whatcorrection == four) && ( v_dir <
                {					      <
                    whatcorrectionqubit = four_up;	      <
                }					      <
                else if ( (whatcorrection == four) && ( v_dir <
                {					      <
                    whatcorrectionqubit = four_down;	      <
                }					      <
                else					      <
                {					      <
                    assert(0);				      <
                }					      <
							      <
                if(debug4)				      <
                {					      <
                    if (first)				      <
                    {					      <
                        cout<< " first ";		      <
                    }					      <
                    else				      <
                    {					      <
                        cout<<" not first ";		      <
                    }					      <
                    if (last)				      <
                    {					      <
                        cout<< " last ";		      <
                    }					      <
                    else				      <
                    {					      <
                        cout<<" not last ";		      <
                    }					      <
							      <
                    if (whatcorrectionqubit == before_up)     <
                    {					      <
                        cout<< " before_up ";		      <
                    }					      <
                    else if (whatcorrectionqubit == before_do <
                    {					      <
                        cout<< " before_down ";		      <
                    }					      <
                    else if(whatcorrectionqubit == next_up)   <
                    {					      <
                        cout<< " next_up ";		      <
                    }					      <
                    else if(whatcorrectionqubit == next_down) <
                    {					      <
                        cout<< " next_down ";		      <
                    }					      <
                    else if(whatcorrectionqubit == four_up)   <
                    {					      <
                        cout<< " four_up ";		      <
                    }					      <
                    else if(whatcorrectionqubit == four_down) <
                    {					      <
                        cout<< " four_down ";		      <
                    }					      <
                    else				      <
                    {					      <
                        assert(0);			      <
                    }					      <
                }					      <
							      <
							      <
							      <
							      <
                switch (whatcorrectionqubit)		      <
                {					      <
                case before_up:				      <
                    correct(x1,(Y+ySize-1)%ySize, 2);	      <
                    Y = (Y+1)%ySize;			      <
                    break;				      <
							      <
							      <
                case before_down:			      <
                    correct(x1,(Y+ySize-1)%ySize, 4);	      <
                    Y = (Y+1)%ySize;			      <
                    break;				      <
                case next_up:				      <
                    correct(x1,(Y+1)%ySize, 1);		      <
                    Y = (Y+1)%ySize;			      <
                    break;				      <
                case next_down:				      <
                    correct(x1,(Y+1)%ySize, 3);		      <
                    Y = (Y+1)%ySize;			      <
                    break;				      <
                case four_down:				      <
                    correct(x1,(Y+ySize-1)%ySize, 4);	      <
                    correct((x1+1)%xSize,Y, 1);		      <
                    correct((x1+1)%xSize,Y, 2);		      <
                    correct(x1,(Y+1)%ySize, 3);		      <
                    Y = (Y+1)%ySize;			      <
                    break;				      <
                case four_up:				      <
                    correct(x1,(Y+ySize-1)%ySize, 2);	      <
                    correct((x1+xSize-1)%ySize,Y, 3);	      <
                    correct((x1+xSize-1)%ySize,Y, 4);	      <
                    correct(x1,(Y+1)%ySize, 1);		      <
                    Y = (Y+1)%ySize;			      <
                    break;				      <
                default:				      <
                    assert(0);				      <
                }					      <
							      <
                //if we were at an octagon it shure must have <
                // (otherwise assert(0);)-->so counter up!    <
                l++;					      <
							      <
            }						      <
            else if ( which_cell_type(x1,Y) == sqr )	      <
            {						      <
							      <
                Y = (Y+1)%ySize;			      <
							      <
            }						      <
            else					      <
            {						      <
                assert(0);				      <
            }// end if octo or square			      <
							      <
            // this makes the loop run a last time after Y hi <
            // No, I do not want to talk about it!	      <
            if (exitnextloop)				      <
            {						      <
                exit = true;				      <
            }						      <
            if (Y == y2)				      <
            {						      <
                exitnextloop = true;			      <
            }						      <
							      <
							      <
							      <
							      <
        } //endofwhileY					      <
    }//endofifdeltay					      <
							      <
							      <
/////////////////////////////////////////////VERTICAL	      <
    // correct in the vertical direction		      <
//Qubits to correct in vertical x Achsis		      <
// go from x1|y2 to x2|y2				      <
// x1 --> x2						      <
							      <
							      <
// use correct( x1, y1, qubitcorr)			      <
							      <
    //do we even need to correct in vertical direction?	      <
    if (delta_x != 0)					      <
    {							      <
        //then start correction				      <
							      <
        //exitvariable					      <
        bool exit = false;				      <
        //exit next time variable			      <
        bool exitnextloop = false;			      <
							      <
        //laufvariable					      <
        int X = x1;					      <
        //countingvariable counting the amount of corrections <
        int l = 1;					      <
							      <
        // while exit is false				      <
        while (!exit)					      <
        {						      <
							      <
            //only if on an octagon			      <
            if ( which_cell_type(X,y2) == octo)		      <
            {						      <
							      <
							      <
                //initialize that stuff			      <
                bool first = false;			      <
                bool last = false;			      <
                correctiontype whatcorrection = wrong_correct <
                correctiontypeQB whatcorrectionqubit = wrong_ <
							      <
							      <
							      <
                //check if first			      <
                if ( l == 1)				      <
                {					      <
                    first = true;			      <
                }					      <
                //check if last				      <
                if ( delta_xy(X,x2,xSize) <= 1 )	      <
                {					      <
                    last = true;			      <
                }					      <
							      <
                //Determine correctiontype		      <
                if ( last && v_end_type == octo )	      <
                {					      <
                    whatcorrection = before;		      <
                }					      <
                else if (first && v_start_type)		      <
                {					      <
                    whatcorrection = next;		      <
                }					      <
                else					      <
                {					      <
                    whatcorrection = four;		      <
                }					      <
							      <
                //Determine correctiontypequbit		      <
							      <
                if ( (whatcorrection == before) && ( v_dir == <
                {					      <
                    whatcorrectionqubit = before_up;	      <
                }					      <
                else if ( (whatcorrection == before) && ( v_d <
                {					      <
                    whatcorrectionqubit = before_down;	      <
                }					      <
                else if ( (whatcorrection == next) && ( v_dir <
                {					      <
                    whatcorrectionqubit = next_up;	      <
                }					      <
                else if ( (whatcorrection == next) && ( v_dir <
                {					      <
                    whatcorrectionqubit = next_down;	      <
                }					      <
                else if ( (whatcorrection == four) && ( v_dir <
                {					      <
                    whatcorrectionqubit = four_up;	      <
                }					      <
                else if ( (whatcorrection == four) && ( v_dir <
                {					      <
                    whatcorrectionqubit = four_down;	      <
                }					      <
                else					      <
                {					      <
                    assert(0);				      <
                }					      <
							      <
							      <
							      <
							      <
							      <
                switch (whatcorrectionqubit)		      <
                {					      <
                case before_up:				      <
                    correct((X+xSize+1)%xSize,y2, 1);	      <
                    X = (X+xSize-1)%xSize;		      <
                    break;				      <
                case before_down:			      <
                    correct((X+xSize-1)%xSize,y2, 3);	      <
                    X = (X+1)%xSize;			      <
                    break;				      <
                case next_up:				      <
                    correct((X+xSize-1)%xSize,y2, 3);	      <
                    X = (X+xSize-1)%xSize;		      <
                    break;				      <
                case next_down:				      <
                    correct((X+xSize+1)%xSize,y2, 1);	      <
                    X = (X+1)%xSize;			      <
                    break;				      <
                case four_down:				      <
                    correct((X+xSize-1)%xSize,y2, 3);	      <
                    correct(X,(y2+ySize-1)%ySize, 2);	      <
                    correct(X,(y2+ySize-1)%ySize, 4);	      <
                    correct((X+xSize+1)%xSize,y2, 1);	      <
                    X = (X+1)%xSize;			      <
                    break;				      <
                case four_up:				      <
                    correct((X+xSize-1)%xSize,y2, 3);	      <
                    correct(X,(y2+ySize-1)%ySize, 2);	      <
                    correct(X,(y2+ySize-1)%ySize, 4);	      <
                    correct((X+xSize+1)%xSize,y2, 1);	      <
                    X = (X+xSize-1)%xSize;		      <
                    break;				      <
                default:				      <
                    assert(0);				      <
                }					      <
							      <
                //if we were at an octagon it shure must have <
                // (otherwise assert(0);)-->so counter up!    <
                l++;					      <
							      <
            }						      <
            else if ( which_cell_type(X,y2) == sqr )	      <
            {						      <
							      <
                switch (v_dir)				      <
                {					      <
                case up:				      <
                    X = (X+xSize-1)%xSize;		      <
                    break;				      <
                case down:				      <
                    X = (X+1)%xSize;			      <
                    break;				      <
                case neither:				      <
                    assert(0);				      <
                default:				      <
                    assert(0);				      <
                }					      <
							      <
							      <
            }						      <
            else					      <
            {						      <
                assert(0);				      <
            }// end if octo or square			      <
							      <
							      <
            // this makes the loop run a last time after X hi <
            // No, I do not want to talk about it!	      <
            if (exitnextloop)				      <
            {						      <
                exit = true;				      <
            }						      <
            if (X == x2)				      <
            {						      <
                exitnextloop = true;			      <
            }						      <
							      <
							      <
							      <
							      <
        } //endofwhileY					      <
    }//endofifdeltax					      <
							      <
							      <
}// end of function I guess...				      <
							      <
							      <
							      <
							      <
// Determines if we need to go up, down or neither in the lat <
vertical_direction Lattice::v_where_to_go (int x1, int x2)    <
{							      <
							      <
    vertical_direction v_dir = wrong_direction;		      <
							      <
    if ( (x1 < x2 && x2 - x1 <  xSize - x2 + x1) ||		    if ( (x1 < x2 && x2 - x1 <  xSize - x2 + x1) ||
            (x2 < x1 && x1 - x2 >  xSize - x1 + x2) )		            (x2 < x1 && x1 - x2 >  xSize - x1 + x2) )
        v_dir = down;					      |	        east = true;
    else if (x1 == x2)					      <
        v_dir = neither;				      <
    else							    else
        v_dir = up;					      |	        east = false;
							      <
    return v_dir;					      <
}							      <
							      <
							      <
							      <
							      <
// Determines if the celltype is square or an octagon	      <
celltype Lattice::which_cell_type ( int x, int y)	      <
{							      <
							      <
    int i = x;						      <
    int j = y;						      <

    celltype type = wrong_type;				      |	    if (debug1) cout << "Correcting line x1=" << x1 << " y1="

    if ( (i%2 && j%2)  || (!(i%2) && !(j%2)) )		      |	    // correct in the southbound direction first
    {							      |	    while (y1 != y2)
        type = octo;					      <
    }							      <
    else if ( (!(i%2) && j%2)  || (i%2 && !(j%2)) )	      <
    {							      <
        type = sqr;					      <
    }							      <
    else						      <
    {								    {
        type = wrong_type;				      |	        y1 = (y1 + 2) % (ySize);
							      >	        correct ( x1, (y1-1+ySize) % ySize);
    }								    }

    return type;					      |	    // if correction in SE direction
							      |	    if (east)
}//end of which_cell_type				      <
							      <
							      <
							      <
//determines distance between coordinates in x direction      <
int Lattice::delta_xy(int xy1, int xy2, int Size)	      <
{							      <
							      <
    int d = min (abs(xy2-xy1), Size-abs(xy2-xy1) );	      <
							      <
    return d;						      <
							      <
}//endof delta_x					      <
							      <
							      <
							      <
//returns true if there is no error syndrome anywhere on the  <
							      <
bool Lattice::is_line()					      <
{							      <
							      <
							      <
    bool is_line_var = false;				      <
    int syndromecounter = 0;				      <
							      <
							      <
    // Identify vertices that represent squares/octagons with <
							      <
							      <
    for (int i = 0; i < xSize; i++)			      <
    {								    {
        for (int j = 0; j < ySize; j++)			      |	        while (x1 != x2)
        {							        {
            bool syndrome = false;			      |	            x1 = (x1 + 2) % (xSize);
// if i,j both odd do OCT-Z-syndrome (detects X Errors)	      |	            correct ( (x1-1+xSize) % xSize, y1);
							      <
            if ( ((i%2) && (j%2)) )			      <
            {						      <
                syndrome = OCTsyndromeZZZZZZZZ(i,j);	      <
            }						      <
//if exactly  one of i and j is odd and one is even do SQ-Z-S <
							      <
            if (  (i%2 && !(j%2))   ||   (!(i%2) && j%2) )    <
            {						      <
                syndrome = SQsyndromeZZZZ(i,j);		      <
            }						      <
							      <
							      <
// if one of the above has a syndrome			      <
            if (syndrome)				      <
            {						      <
                syndromecounter++;			      <
            }						      <
//otherwise go further					      <
        }							        }
							      >	        // if correction in SW direction
    }								    }
							      |	    else
    if (syndromecounter == 2)				      <
    {							      <
        is_line_var = true;				      <
    }							      <
							      <
							      <
    return is_line_var;					      <
							      <
							      <
}							      <
							      <
							      <
							      <
							      <
//generates exactly 1 line of errors on the lattice	      <
							      <
void Lattice::generateline()				      <
{							      <
    int x1 =  -1;					      <
    int y1 = -1;					      <
							      <
    int x2 =  -1;					      <
    int y2 = -1;					      <
							      <
							      <
							      <
							      <
    while(true)						      <
    {								    {
							      |	        while (x1 != x2)
        x1 =  rand()%xSize;	//element [0,xSize]	      <
        y1 = rand()%ySize;	//element [0,ySize]	      <
							      <
        x2 =  rand()%xSize;	//element [0,xSize]	      <
        y2 = rand()%ySize;	//element [0,ySize]	      <
							      <
        //no syndrome at X Octagons erlaubt		      <
        if ( (!(x1%2) && !(y1%2)) || (!(x2%2) && !(y2%2)))    <
        {							        {
            continue;					      |	            x1 = (x1 -2 + xSize) % (xSize);
							      >	            correct ( (x1+1) % xSize, y1);
        }							        }
							      <
							      <
							      <
        //if we have generated two different points stop the  <
        if ((x1 != x2 || y1 != y2)    )			      <
        {						      <
            break;					      <
        }						      <
							      <
    }								    }
							      >	}


							      |	// Generates logical operator  Z1, or Z2 on this lattice whic
							      |	Operator* Lattice::getLogical(string whichOp)
    correctLine( x1, y1, x2, y2);			      <
							      <
							      <
}//end of generateline					      <
							      <
							      <
							      <
//returns true if there is no error syndrome anywhere on the  <
							      <
bool Lattice::is_corrected()				      <
{								{


							      >	    Operator *myOp = new Operator (xSize*ySize/2);

    // Identify vertices that represent squares/octagons with |	    for (int i = 0, k = 0; i < xSize; i++)
							      <
							      <
    for (int i = 0; i < xSize; i++)			      <
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            bool syndrome = false;			      |	            if ((i%2 && j%2) || (!(i%2) && !(j%2)))
// if i,j both odd do OCT-Z-syndrome (detects X Errors)	      |	                continue;
							      |	            if (whichOp == "Z1")
            if ( ((i%2) && (j%2)) )			      <
            {							            {
                syndrome = OCTsyndromeZZZZZZZZ(i,j);	      |	                if (i == 0)
							      >	                {
							      >	                    myOp->ops[k] = Z;
							      >	                }
            }							            }
//if exactly  one of i and j is odd and one is even do SQ-Z-S |	            else if (whichOp == "Z2")
							      <
            if (  (i%2 && !(j%2))   ||   (!(i%2) && j%2) )    <
            {							            {
                syndrome = SQsyndromeZZZZ(i,j);		      |	                if (j == 0)
							      >	                {
							      >	                    myOp->ops[k] = Z;
							      >	                }
            }							            }
							      |	            else
							      <
// if one of the above has a syndrome			      <
            if (syndrome)				      <
            {							            {
                return false;				      |	                assert (0);
            }							            }
//otherwise go further					      |	            k++;
        }							        }
    }								    }

							      <
							      <
//if there was no syndrome anywhere			      <
    return true;					      <
							      <
							      <
}							      <
							      <
							      <
							      <
							      <
							      <
							      <
							      <
// Generates logical operator  Z1, or Z2 on this lattice whic <
Operator* Lattice::getLogical(string whichOp)		      <
{							      <
							      <
    //number of qubits					      <
    Operator *myOp = new Operator (xSize*ySize/2*4);	      <
							      <
    for (int i = 0, l = 0; i < xSize; i++)		      <
    {							      <
        for (int j = 0; j < ySize; j++)			      <
        {						      <
            for (int k = 0; k < zSize; k++)		      <
            {						      <
							      <
                if ( which_cell_type(i,j) == octo || (k == 0) <
                {					      <
                    if(debug8)				      <
                    {					      <
                        cout<<"continue"<<endl;		      <
                    }					      <
                    continue;				      <
							      <
                }					      <
							      <
                if (whichOp == "Z1")			      <
                {					      <
                    //first line squares		      <
                    if (((i == 0) && which_cell_type(i,j) ==  <
                    {					      <
                        if(debug8)			      <
                        {				      <
                            cout<<"Z"<<endl;		      <
                        }				      <
                        myOp->ops[l] = Z;		      <
                    }					      <
                    else				      <
                    {					      <
                        if(debug8)			      <
                        {				      <
                            cout<<"I"<<endl;		      <
                        }				      <
                        myOp->ops[l] = I;		      <
                    }					      <
                }					      <
                else if (whichOp == "Z2")		      <
                {					      <
                    //first column squares		      <
                    if ((j == 0 && which_cell_type(i,j) == sq <
                    {					      <
                        if(debug8)			      <
                        {				      <
                            cout<<"Z"<<endl;		      <
                        }				      <
                        myOp->ops[l] = Z;		      <
                    }					      <
                    else				      <
                    {					      <
                        if(debug8)			      <
                        {				      <
                            cout<<"I"<<endl;		      <
                        }				      <
                        myOp->ops[l] = I;		      <
                    }					      <
                }					      <
                else					      <
                {					      <
                    assert (0);				      <
                }					      <
                l++;					      <
							      <
            }//endofk					      <
        }//endofj					      <
    }//endofi						      <
							      <
    return myOp;						    return myOp;
}								}


// Examimes ErrInit and ErrGuess to determine if error correc	// Examimes ErrInit and ErrGuess to determine if error correc
// Multiplies ErrGuess with operator p.				// Multiplies ErrGuess with operator p.
bool Lattice::success(Operator *p)				bool Lattice::success(Operator *p)
{								{

    // Calculate O = E * E_guessed				    // Calculate O = E * E_guessed
    Operator E(0), EGuessP(0);					    Operator E(0), EGuessP(0);
    for (int i = 0, l = 0; i < xSize; i++)			    for (int i = 0, l = 0; i < xSize; i++)
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            for (int k = 0; k < zSize; k++)		      |	            if ((i%2 && j%2) || (!(i%2) && !(j%2)))
							      >	                continue;
							      >	            E.pushBack (cells[i][j]->ErrInit->ops[0]);
							      >	            if (p)
            {							            {
                if ((i%2 && j%2) || (!(i%2) && !(j%2)) || (k  |	                pauli pErrGuessP = cells[i][j]->ErrGuess->ops
                {					      |	                EGuessP.pushBack (pErrGuessP);
                    continue;				      |	            }
                }					      |	            else
							      |	            {
                E.pushBack (cells[i][j][k]->ErrInit->ops[0]); |	                EGuessP.pushBack (cells[i][j]->ErrGuess->ops[
                if (p)					      <
                {					      <
                    pauli pErrGuessP = cells[i][j][k]->ErrGue <
                    EGuessP.pushBack (pErrGuessP);	      <
                }					      <
                else					      <
                {					      <
                    EGuessP.pushBack (cells[i][j][k]->ErrGues <
                }					      <
            }							            }
        }							        }
    }								    }
    Operator O = E * EGuessP;					    Operator O = E * EGuessP;

    // Generate logical operators  Z1, Z2			    // Generate logical operators  Z1, Z2

    Operator *Z1 = getLogical("Z1");				    Operator *Z1 = getLogical("Z1");
    Operator *Z2 = getLogical("Z2");				    Operator *Z2 = getLogical("Z2");

    assert ( Z1->commute(*Z2));					    assert ( Z1->commute(*Z2));
    if (debug7)						      <
    {							      <
        cout<<"E0: ";					      <
        E.printState();					      <
        cout<<endl;					      <
        cout<<"EG: ";					      <
        EGuessP.printState();				      <
        cout<<endl;					      <
        cout<<"Ob: ";					      <
        O.printState();					      <
        cout<<endl;					      <
        cout<<"Z1: ";					      <
        Z1->printState();				      <
        cout<<endl;					      <
							      <
    }							      <

    // Determine result of error correction			    // Determine result of error correction
    bool result = true;						    bool result = true;
    if ( !O.commute(*Z1) || !O.commute(*Z2) )		      |	    //if ( !O.commute(*Z1) || !O.commute(*Z2))
    {							      |	    if ( !O.commute(*Z1) )
        result = false;						        result = false;
    }							      <

    delete Z1;							    delete Z1;
    delete Z2;							    delete Z2;

    return result;						    return result;
							      <
//der 2. Z muss noch weg dann				      <
    return true;					      <
}								}


							      <
// Print the current state of the lattice. The content of Err	// Print the current state of the lattice. The content of Err
void Lattice::printState(void)					void Lattice::printState(void)
{								{

    for (int i = 0; i < xSize; i++)				    for (int i = 0; i < xSize; i++)
    {								    {
        for (int j = 0; j < ySize; j++)				        for (int j = 0; j < ySize; j++)
        {							        {
            for (int k = 0; k < zSize; k++)		      |	            if ((i%2 && j%2) || (!(i%2) && !(j%2)))
            {						      |	                continue;
                if ((k == 0) || (i%2 && j%2) || (!(i%2) && !( |	            cout << "Error at location X=" << i << " Y=" << j
                    continue;				      |	            cells[i][j]->ErrCurrent->printState();
                cout << "Error at location X=" << i << " Y="  <
                cells[i][j][k]->ErrCurrent->printState();     <
                cout<< endl;				      <
            }						      <
        }							        }
    }								    }
}								}
							      <
// Print the current state of the QB lattice. The content of  <
void Lattice::printStateQB(void)			      <
{							      <
    cout<<"Print Lattice State"<<endl;			      <
							      <
    for (int i = 0; i < xSize; i++)			      <
    {							      <
        for (int l = 0; l < 3; l++)			      <
        {						      <
            for (int j = 0; j < ySize; j++)		      <
            {						      <
							      <
                if ( (i%2 && j%2) || (!(i%2) && !(j%2)))      <
                {					      <
							      <
                    if (l==1)				      <
                    {					      <
                        if(i%2 && j%2)			      <
                        {				      <
                            cout<< "    ";		      <
                            // if there is syndrome print -   <
                            if(OCTsyndromeZZZZZZZZ(i,j))      <
                            {				      <
                                cout<<"-";		      <
                            }				      <
                            else			      <
                            {				      <
                                cout<<"+";		      <
                            }				      <
                            cout<<"    ";		      <
                            continue;			      <
                        }				      <
                        else				      <
                        {				      <
                            cout<< "         ";		      <
                            continue;			      <
                        }				      <
							      <
                    }					      <
                    else				      <
                    {					      <
                        cout<< "         ";		      <
                        continue;			      <
                    }					      <
                }					      <
							      <
							      <
							      <
                if (l==0)				      <
                {					      <
                    cout<<" ";				      <
                    cells[i][j][1]->ErrCurrent->printState(); <
                    cout<<" --- ";			      <
                    cells[i][j][2]->ErrCurrent->printState(); <
                    cout<<" ";				      <
							      <
							      <
                }					      <
                else if (l==1)				      <
                {					      <
                    cout<<"  | ";			      <
                    //if there is syndrome print -	      <
                    if(SQsyndromeZZZZ(i,j))		      <
                    {					      <
                        cout<<"-";			      <
                    }					      <
                    else				      <
                    {					      <
                        cout<<"+";			      <
                    }					      <
                    cout <<" |  ";			      <
                }					      <
                else if (l==2)				      <
                {					      <
                    cout<<" ";				      <
                    cells[i][j][3]->ErrCurrent->printState(); <
                    cout<<" --- ";			      <
                    cells[i][j][4]->ErrCurrent->printState(); <
                    cout<<" ";				      <
                }					      <
							      <
							      <
							      <
							      <
							      <
							      <
							      <
							      <
							      <
							      <
            }//end of j					      <
            cout<<endl;					      <
        }// end of l					      <
        cout<<endl;					      <
							      <
							      <
							      <
    }//end of i						      <
}//end of print						      <
							      <
							      <
							      <
							      <


